\input texinfo   @c -*-texinfo-*-
@c %**start of header
@setfilename python_recutils.info
@documentencoding UTF-8
@ifinfo
@*Generated by Sphinx 1.1.3.@*
@end ifinfo
@settitle Python Bindings for GNU Recutils
@paragraphindent 2
@exampleindent 4
@afourlatex
@dircategory Miscellaneous
@direntry
* python_recutils: (python_recutils.info). One line description of project.
@end direntry

@c %**end of header

@copying

Python Bindings for GNU Recutils 1.0, September 21, 2013

Copyright @copyright{} 2013, Maninya M.
@quotation
     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with no Invariant Sections, no Front-Cover Texts, and
     no Back-Cover Texts. A copy of the license is included in the
     section entitled "GNU Free Documentation License".

@end quotation

@end copying

@titlepage
@title Python Bindings for GNU Recutils
@insertcopying
@end titlepage
@contents

@c %** start of user preamble

@c %** end of user preamble

@ifnottex
@node Top
@top Python Bindings for GNU Recutils
@insertcopying
@end ifnottex

@c %**start of body
@anchor{index doc}@anchor{0}
@c python_recutils documentation master file, created by
@c sphinx-quickstart on Sat Sep 21 21:32:00 2013.
@c You can adapt this file completely to your liking, but it should at least
@c contain the root `toctree` directive.

This manual documents version 1.0 of the Python bindings for GNU Recutils, version 1.5.

@menu
* Introduction:: 
* Modules:: 
* A Little Example:: 

@end menu

@node Introduction,Modules,Top,Top
@anchor{intro python-bindings-for-gnu-recutils}@anchor{1}@anchor{intro introduction}@anchor{2}@anchor{intro intro}@anchor{3}@anchor{intro doc}@anchor{4}
@chapter Introduction


The Python bindings for GNU Recutils follow the Python/C API and should work with Python 2.7 or higher. The extension module has been written to implement new built-in object types similar to the structures in librec (the GNU Recutils C library), and to call the corresponding C library functions. There is also a Python module that is part of the bindings. It acts as an exception handler and binds the enum datatypes from the C library.

You can install the bindings from source using @code{python setup.py install} or using @code{pip install python/} if you have ``pip`` installed. It is a good idea to use pip to install Python packages since it can help in easy uninstallation/reinstallation if you want to upgrade. You may consider using virtualenv to create isolated Python environments.

The @code{python} subdirectory in @code{torture/} contains some example-test programs in Python that show how to perform operations on recfiles. It would be a good idea to have a look at these as you read this manual.

The object types that extend the C library in Python are classes, and the usual rules of classes apply.

@node Modules,A Little Example,Introduction,Top
@anchor{modules modules}@anchor{5}@anchor{modules doc}@anchor{6}@anchor{modules id1}@anchor{7}
@chapter Modules


The bindings consist of two modules, @code{recutils} and @code{pyrec}. The module @code{recutils} is the extension written in the Python/C API that provides the librec library functions in Python. The module @code{pyrec} is a Python module written to handle exceptions within the functions itself, and also to wrap C enum datatypes.

@menu
* recutils - GNU Recutils:: 
* Functions in recutils outside Classes:: 
* pyrec - Handle exceptions and enum datatypes:: 

@end menu

@node recutils - GNU Recutils,Functions in recutils outside Classes,,Modules
@anchor{modules recutils-gnu-recutils}@anchor{8}
@section recutils - GNU Recutils


This module provides access to functions in Recutils. Please note that some functions require the @code{pyrec} module to be imported for exceptions to be handled.

recdb (built-in class)
@anchor{modules recdb}@anchor{9}
@deffn {Class} recdb

The constructor creates and returns a Database class object. It has the following methods:

size() (recdb method)
@anchor{modules recdb size}@anchor{a}
@deffn {Method} size ()

Return the number of record sets contained in a given database.
@end deffn

pyloadfile() (recdb method)
@anchor{modules recdb pyloadfile}@anchor{b}
@deffn {Method} pyloadfile (filename)

Load a file into a Database object. @emph{filename} is a string containing the name of any recfile. Does not handle exception on failure. See
module @code{pyrec}.
@end deffn

pywritefile() (recdb method)
@anchor{modules recdb pywritefile}@anchor{c}
@deffn {Method} pywritefile (filename)

Write to file from a Database object. This function overwrites a non-empty file. Does not handle exception on failure. See module @code{pyrec}.
@end deffn

pyappendfile() (recdb method)
@anchor{modules recdb pyappendfile}@anchor{d}
@deffn {Method} pyappendfile (filename)

Append to file from a Database object. This function appends to a non-empty file. Does not handle exception on failure.
See module @code{pyrec}.
@end deffn

get_rset() (recdb method)
@anchor{modules recdb get_rset}@anchor{e}
@deffn {Method} get_rset (position)

Return the record set occupying the given position in the database. If no such record set is contained in the database then None is
returned.
@end deffn

pyinsert_rset() (recdb method)
@anchor{modules recdb pyinsert_rset}@anchor{f}
@deffn {Method} pyinsert_rset (recset, position)

Insert the given record set into the given database at the given position. If POSITION >= rec_rset_size (DB), RSET is appended to the list of fields. If POSITION < 0, RSET is prepended. Otherwise RSET is inserted at the specified position. Does not handle exception on failure. See module @code{pyrec}.
@end deffn

pyremove_rset() (recdb method)
@anchor{modules recdb pyremove_rset}@anchor{10}
@deffn {Method} pyremove_rset (position)

Remove the record set contained in the given position into the given database. If POSITION >= rec_db_size (DB), the last record set is
deleted. If POSITION <= 0, the first record set is deleted. Otherwise the record set occupying the specified position is deleted. Does not handle exception on failure. See module @code{pyrec}.
@end deffn

type() (recdb method)
@anchor{modules recdb type}@anchor{11}
@deffn {Method} type ()

Determine whether an rset named TYPE exists in a database.  If TYPE is None then it refers to the default record set. Returns 1 for success and 0 otherwise.
@end deffn

get_rset_by_type() (recdb method)
@anchor{modules recdb get_rset_by_type}@anchor{12}
@deffn {Method} get_rset_by_type ()

Get the rset with the given type from the DB. Returns None if there is no record set having that type.
@end deffn

@strong{DATABASE HIGH-LEVEL FUNCTIONS}

query() (recdb method)
@anchor{modules recdb query}@anchor{13}
@deffn {Method} query (type, join, index, sexp, fast_string, random, fexp, password, group_by, sort_by, flags)

Query for some data in a database.  The resulting data is returned in a record set. This function takes the following arguments:

TYPE

@quotation

The type of records to query. This string must identify a record set contained in the database. If TYPE is None then the default record
set, if any, is queried.
@end quotation

JOIN

@quotation

If not None, this argument must be a string denoting a field name. This field name must be a foreign key (field of type 'rec') defined
in the selected record set. The query operation will do an inner join using T1.Field = T2.Field as join criteria.
@end quotation

INDEX

@quotation

If not None, this argument is a pointer to a buffer containing pairs of Min, Max indexes, identifying intervals of valid records. The
list of ends with the pair REC_Q_NOINDEX,REC_Q_NOINDEX.
INDEX is mutually exclusive with any other selection option.
@end quotation

SEX

@quotation

Selection expression which is evaluated for every record in the referred record set. If SEX is None then all records are selected.
This argument is mutually exclusive with any other selection option.
@end quotation

FAST_STRING

@quotation

If this argument is not None then it is a string which is used as a fixed pattern.  Records featuring fields containing FAST_STRING as a
substring in their values are selected. This argument is mutually exclusive with any other selection option.
@end quotation

RANDOM

@quotation

If not 0, this argument indicates the number of random records to select from the referred record set.
This argument is mutually exclusive with any other selection option.
@end quotation

FEX

@quotation

Field expression to apply to the matching records to build the records in the result record set. If FEX is None then the matching
records are unaltered.
@end quotation

PASSWORD

@quotation

Password to use to decrypt confidential fields. If the password does not work then the encrypted fields are returned as-is. If PASSWORD
is None, or if it is the empty string, then no attempt to decrypt encrypted fields will be performed.
@end quotation

GROUP_BY

@quotation

If not None, group the record set by the given field names.
@end quotation

SORT_BY

@quotation

If not None, sort the record set by the given field names.
@end quotation

FLAGS

@quotation

ORed value of any of the following flags:

REC_Q_DESCRIPTOR

If set returned record set will feature a record descriptor. If the query is involving a single record set then the descriptor will be a
copy of the descriptor of the referred record set, and will feature the same record type name. Otherwise it will be built from the
several descriptors of the involved record sets, and the record type name will be formed concatenating the type names of the involved
record sets. If this flag is not activated then the returned record set won't feature a record descriptor.

REC_Q_ICASE

If set the string operations in the selection expression will be case-insensitive. If FALSE any string operation will be
case-sensitive.
@end quotation

Return None if there is not enough memory to perform the operation.
@end deffn

insert() (recdb method)
@anchor{modules recdb insert}@anchor{14}
@deffn {Method} insert (type, index, sexp, fast_string, random, password, recp, flags)

Insert a new record into a database, either appending it to some record set or replacing one or more existing records. This function takes
the following arguments:

TYPE

@quotation

Type of the new record. If there is an existing record set holding records of that type then the record is added to it. Otherwise a new
record set is appended into the database.
@end quotation

INDEX

@quotation

If not None, this argument is a pointer to a buffer containing pairs of Min, Max indexes, identifying intervals of valid records. The
list of ends with the pair REC_Q_NOINDEX,REC_Q_NOINDEX.
INDEX is mutually exclusive with any other selection option.
@end quotation

SEX

@quotation

Selection expression which is evaluated for every record in the referred record set. If SEX is None then all records are selected.
This argument is mutually exclusive with any other selection option.
@end quotation

FAST_STRING

@quotation

If this argument is not None then it is a string which is used as a fixed pattern. Records featuring fields containing FAST_STRING as a
substring in their values are selected. This argument is mutually exclusive with any other selection option.
@end quotation

RANDOM

@quotation

If not 0, this argument indicates the number of random records to select from the referred record set.
This argument is mutually exclusive with any other selection option.
@end quotation

PASSWORD

@quotation

Password to use to decrypt confidential fields. If the password does not work then the encrypted fields are returned as-is. If PASSWORD
is None, or if it is the empty string, then no attempt to decrypt encrypted fields will be performed.
@end quotation

RECORD

@quotation

Record to insert. If more than one record is replaced in the database they will be substitued with copies of this record.
@end quotation

FLAGS

@quotation

ORed value of any of the following flags:

REC_F_ICASE

If set the string operations in the selection expression will be case-insensitive. If FALSE any string operation will be
case-sensitive.

REC_F_NOAUTO

If set then no auto-fields will be added to the newly created records in the database.
@end quotation

If no selection option is used then the new record is appended to either an existing record set identified by TYPE or to a newly created
record set. If some selection option is used then the matching existing records will be replaced. This function returns 0 if there is not
enough memory to perform the operation.
@end deffn

delete() (recdb method)
@anchor{modules recdb delete}@anchor{15}
@deffn {Method} delete (type, index, sexp, fast_string, random, flags)

Delete records from a database, either physically removing them or commenting them out. This function takes the following arguments:

TYPE

@quotation

Type of the records to remove.
@end quotation

INDEX

@quotation

If not None, this argument is a pointer to a buffer containing pairs of Min, Max indexes, identifying intervals of valid records. The
list of ends with the pair REC_Q_NOINDEX,REC_Q_NOINDEX.
INDEX is mutually exclusive with any other selection option.
@end quotation

SEX

@quotation

Selection expression which is evaluated for every record in the referred record set. If SEX is None then all records are selected.
This argument is mutually exclusive with any other selection option.
@end quotation

FAST_STRING

@quotation

If this argument is not None then it is a string which is used as a fixed pattern.  Records featuring fields containing FAST_STRING as a
substring in their values are selected. This argument is mutually exclusive with any other selection option.
@end quotation

RANDOM

@quotation

If not 0, this argument indicates the number of random records to select from the referred record set.
This argument is mutually exclusive with any other selection option.
@end quotation

FLAGS

@quotation

ORed value of any of the following flags:

REC_F_ICASE

If set the string operations in the selection expression will be case-insensitive. If FALSE any string operation will be
case-sensitive.

REC_F_COMMENT_OUT

If set the selected records will be commented out instead of physically removed from the database.
@end quotation

Return 0 if there is not enough memory to perform the operation.
@end deffn

set() (recdb method)
@anchor{modules recdb set}@anchor{16}
@deffn {Method} set (type, index, sexp, fast_string, random, fexp, action, action_arg, flags)

Manipulate the fields of the selected records in a database: remove them, set their values or rename them. This function takes the
following arguments:

TYPE

@quotation

The type of records to act in.
@end quotation

INDEX

@quotation

If not None, this argument is a pointer to a buffer containing pairs of Min, Max indexes, identifying intervals of valid records. The
list of ends with the pair REC_Q_NOINDEX,REC_Q_NOINDEX.
INDEX is mutually exclusive with any other selection option.
@end quotation

SEX

@quotation

Selection expression which is evaluated for every record in the referred record set. If SEX is None then all records are selected.
This argument is mutually exclusive with any other selection option.
@end quotation

FAST_STRING

@quotation

If this argument is not None then it is a string which is used as a fixed pattern. Records featuring fields containing FAST_STRING as a
substring in their values are selected. This argument is mutually exclusive with any other selection option.
@end quotation

RANDOM

@quotation

If not 0, this argument indicates the number of random records to select from the referred record set.
This argument is mutually exclusive with any other selection option.
@end quotation

FEX

@quotation

Field expression selecting the fields in the selected records which will be modified.
@end quotation

ACTION

@quotation

Action to perform to the selected fields. Valid values for this argument are:

REC_SET_ACT_RENAME

Rename the matching fields to the string pointed by ACTION_ARG.

REC_SET_ACT_SET

Set the value of the matching fields to the string pointed by ACTION_ARG.

REC_SET_ACT_ADD

Add new fields with the names specified in the fex to the selected records. The new fields will have the string pointed by ACTION_ARG as
their value.

REC_SET_ACT_SETADD

Set the selected fields to the value pointed by ACTION_ARG. IF the fields dont exist then create them with that value.

REC_SET_ACT_DELETE

Delete the selected fields. ACTION_ARG is ignored by this action.

REC_SET_ACT_COMMENT

Comment out the selected fields. ACTION_ARG is ignored by this action.
@end quotation

ACTION_ARG

@quotation

Argument to the selected action. It is ok to pass None for actions which dont require an argument.
@end quotation

FLAGS

@quotation

ORed value of any of the following flags:

REC_F_ICASE

If set the string operations in the selection expression will be case-insensitive. If FALSE any string operation will be
case-sensitive.

REC_F_COMMENT_OUT

If set the selected records will be commented out instead of physically removed from the database.
@end quotation

Return 0 if there is not enough memory to perform the operation.
@end deffn

int_check() (recdb method)
@anchor{modules recdb int_check}@anchor{17}
@deffn {Method} int_check (check_descriptors_p, remote_descriptors_p, errors)

Check the integrity of all the record sets stored in a given database. This function returns the number of errors found. Descriptive
messages about the errors are appended to ERRORS.
@end deffn
@end deffn

rset (built-in class)
@anchor{modules rset}@anchor{18}
@deffn {Class} rset

The constructor creates and returns a Record-set class object. It has the following methods:

num_records() (rset method)
@anchor{modules rset num_records}@anchor{19}
@deffn {Method} num_records ()

Return the number of records stored in the given record set.
@end deffn

descriptor() (rset method)
@anchor{modules rset descriptor}@anchor{1a}
@deffn {Method} descriptor ()

Return the record descriptor of a given record set. None is returned if the record set does not feature a record descriptor.
@end deffn

type() (rset method)
@anchor{modules rset type}@anchor{1b}
@deffn {Method} type ()

Return the type name of a record set. None is returned if the record set does not feature a record descriptor.
@end deffn
@end deffn

record (built-in class)
@anchor{modules record}@anchor{1c}
@deffn {Class} record

The constructor creates and returns a Record class object. It has the following methods:

num_fields() (record method)
@anchor{modules record num_fields}@anchor{1d}
@deffn {Method} num_fields ()

Return the number of fields stored in the given record.
@end deffn

contains_value() (record method)
@anchor{modules record contains_value}@anchor{1e}
@deffn {Method} contains_value (value, case_insensitive)

Determine whether a record contains some field whose value is VALUE. The string comparison can be either case-sensitive or case-
insensitive.
@end deffn

contains_field() (record method)
@anchor{modules record contains_field}@anchor{1f}
@deffn {Method} contains_field (field_name, field_value)

Determine whether a record contains a field whose name is FIELD_NAME and value FIELD_VALUE.
@end deffn
@end deffn

sex (built-in class)
@anchor{modules sex}@anchor{20}
@deffn {Class} sex (case_insensitive)

The constructor creates and returns a Selection Expression class object. It has the following methods:

pycompile() (sex method)
@anchor{modules sex pycompile}@anchor{21}
@deffn {Method} pycompile (expr)

Compile a sex. Sexes must be compiled before being used. If there is a parse error return 0. Does not handle exception on failure. See
module @code{pyrec}.
@end deffn

pyeval() (sex method)
@anchor{modules sex pyeval}@anchor{22}
@deffn {Method} pyeval (rec, status)

Apply a sex expression to a record, setting STATUS in accordance: 1 if the record matched the sex, 0 otherwise. The function returns the
same value that is stored in STATUS. Does not handle exception on failure. See module @code{pyrec}.
@end deffn

eval_str() (sex method)
@anchor{modules sex eval_str}@anchor{23}
@deffn {Method} eval_str (rec)

Apply a sex expression to a record and get the result as an allocated string.
@end deffn
@end deffn

fex (built-in class)
@anchor{modules fex}@anchor{24}
@deffn {Class} fex (str, kind)

The constructor to parse and create a Field Expression, and return it. A fex kind shall be specified in KIND (enum type). If STR does not
contain a valid FEX of the given kind then None is returned. If there is not enough memory to perform the operation then None is returned. If
STR is None then an empty fex is returned. It has the following methods:

size() (fex method)
@anchor{modules fex size}@anchor{25}
@deffn {Method} size ()

Get the number of elements stored in a field expression.
@end deffn

member_p() (fex method)
@anchor{modules fex member_p}@anchor{26}
@deffn {Method} member_p (fname, min, max)

Check whether a given field (or set of fields) identified by their name and indexes, are contained in a fex.
@end deffn

get() (fex method)
@anchor{modules fex get}@anchor{27}
@deffn {Method} get (position)

Get the element of a field expression occupying the given position. If the position is invalid then None is returned.
@end deffn

append() (fex method)
@anchor{modules fex append}@anchor{28}
@deffn {Method} append (fname, min, max)

Append an element at the end of the fex and return it. This function returns None if there is not enough memory to perform the    operation.
@end deffn

all_calls_p() (fex method)
@anchor{modules fex all_calls_p}@anchor{29}
@deffn {Method} all_calls_p ()

Determine whether all the elements of the given FEX are function calls.
@end deffn

check() (fex method)
@anchor{modules fex check}@anchor{2a}
@deffn {Method} check (str, kind)

Check whether a given string STR contains a proper fex description of type KIND.
@end deffn

sort() (fex method)
@anchor{modules fex sort}@anchor{2b}
@deffn {Method} sort ()

Sort the elements of a fex using the 'min' index of the elements as the sorting criteria.
@end deffn

str() (fex method)
@anchor{modules fex str}@anchor{2c}
@deffn {Method} str (kind)

Get the written form of a field expression. This function returns None if there is not enough memory to perform the operation.
@end deffn
@end deffn

field (built-in class)
@anchor{modules field}@anchor{2d}
@deffn {Class} field

The constructor creates and returns a Field class object. It has the following methods:

name() (field method)
@anchor{modules field name}@anchor{2e}
@deffn {Method} name ()

Return a string containing the name of a field. Note that this function can't return the empty string for a properly initialized field.
@end deffn

value() (field method)
@anchor{modules field value}@anchor{2f}
@deffn {Method} value ()

Return a string containing the value of a field, i.e. the string stored in the field. The returned string may be empty if the field has no
value, but never None.
@end deffn

set_name() (field method)
@anchor{modules field set_name}@anchor{30}
@deffn {Method} set_name (name)

Set the name of a field. This function returns 0 if there is not enough memory to perform the operation.
@end deffn

set_value() (field method)
@anchor{modules field set_value}@anchor{31}
@deffn {Method} set_value (value)

Set the value of a given field to the given string.  This function returns 0 if there is not enough memory to perform the operation.
@end deffn

source() (field method)
@anchor{modules field source}@anchor{32}
@deffn {Method} source ()

Return a string describing the source of the field. The specific meaning of the source depends on the user: it may be a file name, or
something else. This function returns None for a field for which a source was never set.
@end deffn

set_source() (field method)
@anchor{modules field set_source}@anchor{33}
@deffn {Method} set_source ()

Set a string describing the source of the field. Any previous string associated to the field is destroyed and the memory it occupies is
freed. This function returns 0 if there is not enough memory to perform the operation.
@end deffn

location() (field method)
@anchor{modules field location}@anchor{34}
@deffn {Method} location ()

Return an integer representing the location of the field within its source. The specific meaning of the location depends on the user: it
may be a line number, or something else. This function returns 0 for fields not having a defined source.
@end deffn

location_str() (field method)
@anchor{modules field location_str}@anchor{35}
@deffn {Method} location_str ()

Return the textual representation for the location of a field within its source. This function returns None for fields not having a defined
source.
@end deffn

char_location() (field method)
@anchor{modules field char_location}@anchor{36}
@deffn {Method} char_location ()

Return an integer representing the char location of the field within its source. The specific meaning of the location depends on the user,
usually being the offset in bytes since the beginning of a file or memory buffer. This function returns 0 for fields not having a defined
source.
@end deffn

@c method::char_location_str()
@c 
@c Return the textual representation for the char location of a field within its source. This function returns None for fields not having a
@c defined source.
@end deffn

comment (built-in class)
@anchor{modules comment}@anchor{37}
@deffn {Class} comment (text)

The constructor creates and returns a Comment class object. None is returned if there is not enough memory to perform the operation.It has the
following methods:

text() (comment method)
@anchor{modules comment text}@anchor{38}
@deffn {Method} text ()

Return a string containing the text in the comment.
@end deffn

set_text() (comment method)
@anchor{modules comment set_text}@anchor{39}
@deffn {Method} set_text (text)

Set the text of a comment. Any previous text associated with the comment is destroyed and its memory freed.
@end deffn
@end deffn

buffer (built-in class)
@anchor{modules buffer}@anchor{3a}
@deffn {Class} buffer (data, size)

The constructor creates and returns a Buffer class object. A flexible buffer is a buffer to which stream-like operations can be applied. Its
size will grow as required.
@end deffn

@node Functions in recutils outside Classes,pyrec - Handle exceptions and enum datatypes,recutils - GNU Recutils,Modules
@anchor{modules functions-in-recutils-outside-classes}@anchor{3b}
@section Functions in recutils outside Classes


field_equal_p() (built-in function)
@anchor{modules field_equal_p}@anchor{3c}
@deffn {Function} field_equal_p (field1, field2)

Determine whether two given field objects are equal (i.e. they have equal names but possibly different values).
@end deffn

comment_equal_p() (built-in function)
@anchor{modules comment_equal_p}@anchor{3d}
@deffn {Function} comment_equal_p (comment1, comment2)

Determine whether the texts stored in two given comment objects are equal.
@end deffn

@node pyrec - Handle exceptions and enum datatypes,,Functions in recutils outside Classes,Modules
@anchor{modules pyrec-handle-exceptions-and-enum-datatypes}@anchor{3e}
@section pyrec - Handle exceptions and enum datatypes


This module provides exception handling and binds the enum datatypes of the C library. The classes in this module inherit from the base classes in the @emph{recutils} module, the methods just have the additional ability to handle exceptions. However, this class is required to use the enum datatypes of the C library.

Recdb (built-in class)
@anchor{modules Recdb}@anchor{3f}
@deffn {Class} Recdb

This class inherits from the @code{recutils.recdb} class. The constructor creates and returns a Database class object. It has the following
methods:

loadfile() (Recdb method)
@anchor{modules Recdb loadfile}@anchor{40}
@deffn {Method} loadfile (filename)

Load a file into a Database object. @emph{filename} is a string containing the name of any recfile. Catches exception if load fails.
@end deffn

writefile() (Recdb method)
@anchor{modules Recdb writefile}@anchor{41}
@deffn {Method} writefile (filename)

Write to file from a Database object. This function overwrites a non-empty file. Catches exception if write fails.
@end deffn

appendfile() (Recdb method)
@anchor{modules Recdb appendfile}@anchor{42}
@deffn {Method} appendfile (filename)

Append to file from a Database object. This function appends to a non-empty file. Catches exception if append fails.
@end deffn

insert_rset() (Recdb method)
@anchor{modules Recdb insert_rset}@anchor{43}
@deffn {Method} insert_rset (recset, position)

Insert the given record set into the given database at the given position. If POSITION >= rec_rset_size (DB), RSET is appended to the list
of fields. If POSITION < 0, RSET is prepended. Otherwise RSET is inserted at the specified position. Catches exception if insertion fails.
@end deffn

remove_rset() (Recdb method)
@anchor{modules Recdb remove_rset}@anchor{44}
@deffn {Method} remove_rset (position)

Remove the record set contained in the given position into the given database. If POSITION >= rec_db_size (DB), the last record set is
deleted. If POSITION <= 0, the first record set is deleted. Otherwise the record set occupying the specified position is deleted. Catches
exception if removal fails.
@end deffn
@end deffn

Fexenum (built-in class)
@anchor{modules Fexenum}@anchor{45}
@deffn {Class} Fexenum

This class inherits from the @code{recutils.fex} class. It is used to handle the enum type that the internal C function for fexes requires. This
is achieved by having the following attributes initialized from 0 to 2.

Fexenum.REC_FEX_SIMPLE (built-in variable)
@anchor{modules Fexenum REC_FEX_SIMPLE}@anchor{46}
@deffn {Data} REC_FEX_SIMPLE
@end deffn

Fexenum.REC_FEX_CSV (built-in variable)
@anchor{modules Fexenum REC_FEX_CSV}@anchor{47}
@deffn {Data} REC_FEX_CSV
@end deffn

Fexenum.REC_FEX_SUBSCRIPTS (built-in variable)
@anchor{modules Fexenum REC_FEX_SUBSCRIPTS}@anchor{48}
@deffn {Data} REC_FEX_SUBSCRIPTS
@end deffn
@end deffn

RecSetenum (built-in class)
@anchor{modules RecSetenum}@anchor{49}
@deffn {Class} RecSetenum

This class inherits from the @code{recutils.recdb} class. It is used to handle the enum type that the internal C function for the DB @code{set}
requires. The following attributes are initialized from 0 to 6.

RecSetenum.REC_SET_ACT_NONE (built-in variable)
@anchor{modules RecSetenum REC_SET_ACT_NONE}@anchor{4a}
@deffn {Data} REC_SET_ACT_NONE
@end deffn

RecSetenum.REC_SET_ACT_RENAME (built-in variable)
@anchor{modules RecSetenum REC_SET_ACT_RENAME}@anchor{4b}
@deffn {Data} REC_SET_ACT_RENAME
@end deffn

RecSetenum.REC_SET_ACT_SET (built-in variable)
@anchor{modules RecSetenum REC_SET_ACT_SET}@anchor{4c}
@deffn {Data} REC_SET_ACT_SET
@end deffn

RecSetenum.REC_SET_ACT_ADD (built-in variable)
@anchor{modules RecSetenum REC_SET_ACT_ADD}@anchor{4d}
@deffn {Data} REC_SET_ACT_ADD
@end deffn

RecSetenum.REC_SET_ACT_SETADD (built-in variable)
@anchor{modules RecSetenum REC_SET_ACT_SETADD}@anchor{4e}
@deffn {Data} REC_SET_ACT_SETADD
@end deffn

RecSetenum.REC_SET_ACT_DELETE (built-in variable)
@anchor{modules RecSetenum REC_SET_ACT_DELETE}@anchor{4f}
@deffn {Data} REC_SET_ACT_DELETE
@end deffn

RecSetenum.REC_SET_ACT_COMMENT (built-in variable)
@anchor{modules RecSetenum REC_SET_ACT_COMMENT}@anchor{50}
@deffn {Data} REC_SET_ACT_COMMENT
@end deffn
@end deffn

RecSex (built-in class)
@anchor{modules RecSex}@anchor{51}
@deffn {Class} RecSex (case_insensitive)

This class inherits from the @code{recutils.sex} class. The constructor takes a boolean argument, to indicate case insensitivity for the
selection expression. It has the following methods:

compile() (RecSex method)
@anchor{modules RecSex compile}@anchor{52}
@deffn {Method} compile (expr)

Compile a sex. Sexes must be compiled before being used. If there is a parse error return 0. Catches exception on error.
@end deffn

eval() (RecSex method)
@anchor{modules RecSex eval}@anchor{53}
@deffn {Method} eval (rec, status)

Apply a sex expression to a record, setting STATUS in accordance: 1 if the record matched the sex, 0 otherwise. The function returns
the same value that is stored in STATUS. Catches exception on error.
@end deffn
@end deffn

@node A Little Example,Walkthrough,Modules,Top
@anchor{examples doc}@anchor{54}@anchor{examples examples}@anchor{55}@anchor{examples a-little-example}@anchor{56}
@chapter A Little Example


You can find some example programs in @code{torture/python/} that will give you an idea of how to use the bindings to access librec in Python. To start, always import the @code{recutils} and @code{pyrec} modules so the functions are available to your program.

In the example showing read-only processing, some low-level functions are shown to get information from recfiles. You can also check if particular information exists.

In the other example program, some high-level functions demonstrate how to query for records/record-sets having desired information, insertion, deletion as well as manipulation of databases. Please note the use of enum datatypes that are required by certain functions. You can also check the integrity of your recfiles in Python.

Once you have the bindings installed, here is a little example to help you get started. The walkthrough is below.

@example
#!/usr/bin/python
import sys
import recutils
import pyrec


db = pyrec.Recdb()
db1 = pyrec.Recdb()
db.loadfile("movies.rec")

sexp = pyrec.RecSex(1)
b = sexp.pycompile("Audio = 'German'")

print "Query for a record set consisting of a list of German language movies"
queryrset = db.query("movies", None, None, sex1, None, 10, None, None, None, None, 0)
num_rec = queryrset.num_records()
print "Number of queried records = ",num_rec

db1.insert_rset(queryrset,2);
db1.writefile("german.rec")
@end example

@noindent

The above script can be saved into a file (eg: @cite{little_example.py}), and run like this:

@example
python little_example.py
@end example

@noindent

@menu
* Walkthrough:: 

@end menu

@node Walkthrough,,A Little Example,A Little Example
@anchor{examples walkthrough}@anchor{57}
@section Walkthrough


Start by importing the modules that are going to give you access to the recutils functions.

@example
import recutils
import pyrec
@end example

@noindent

Next, create the databases.

@example
db = pyrec.Recdb()
db1 = pyrec.Recdb()
db.loadfile("movies.rec")
@end example

@noindent

The @cite{Recdb()} constructor creates and returns a database class object. We create two objects here, @cite{db} and @cite{db1}. @cite{loadfile()} then loads the
movie database into @cite{db}.

@example
sexp = pyrec.RecSex(1)
b = sexp.pycompile("Audio = 'German'")
@end example

@noindent

@cite{RecSex()} creates and returns a selection expression object. Its argument is a @code{case_insensitive} boolean flag. SEXES need to be compiled before being used, so let's query for German language movies.

@example
print "Query for a record set consisting of a list of German language movies"
queryrset = db.query("movies", None, None, sex1, None, 10, None, None, None, None, 0)
num_rec = queryrset.num_records()
print "Number of queried records = ",num_rec
@end example

@noindent

Call the @cite{query()} function on @cite{db} and all the German movies should go into @cite{queryrset}.

@example
db1.insert_rset(queryrset,2);
db1.writefile("german.rec")
@end example

@noindent

Lastly, just to be sure we got what we wanted, we insert @cite{queryrset} into @cite{db1}, the second database object we created, and then write it to file. Opening @cite{german.rec} should give you the list of all the German movies you wanted to see.

You can try out more such operations with the help of the example-test programs in @code{torture/python/}.

@c %**end of body
@bye
