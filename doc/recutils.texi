\input texinfo
@comment %**start of header
@setfilename recutils.info
@settitle GNU Recutils
@afourpaper
@comment %**end of header

@set VERSION 1.0

@copying
Copyright @copyright{} 2009, 2010 Jose E. Marchesi
Copyright @copyright{} 1994, 1995, 1996, 1997, 1998, 1999, 2000,
2001, 2002, 2003, 2004, 2005, 2006, 2009, 2010 Free Software
Foundation, Inc.

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.2 or
any later version published by the Free Software Foundation; with no
Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts. A
copy of the license is included in the section entitled ``GNU Free
Documentation License''.
@end quotation
@end copying

@dircategory Database
@direntry
* recutils: (recutils). The GNU Recutils manual.
@end direntry

@titlepage
@sp
@center @titlefont{GNU Recutils}
@sp 4
@center Updated for version @value{VERSION}.
@sp 5
@center Jos@'e E. Marchesi
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@contents

@ifnottex
@node Top
@top GNU Recutils

This manual documents version @value{VERSION} of the GNU rec utilities.

@insertcopying
@end ifnottex

@menu
Overview
* Introduction::        Introducing the GNU recutils.
* A Little Example::    Recutils in action.

The Rec Format
* Fields and Records::  The basic structures conforming Rec files.
* Record Descriptors::  Describing different types of records.
* Compound Field Names:: Referencing record instances.
* Comments::            Comments are useful to store meta data.
* Date input formats::  Textual date representations that can be used
                          in Rec files.
* Field Types::         Types for fields can be defined in record
                          descriptors.

Utilities
* Common Options::      Common command line arguments for the record
                          utilities.
* recinf::              Printing information about rec files.
* recsel::              Selecting records.
* recins::              Inserting records.
* recdel::              Deleting records.
* recset::              Managing fields.
* recfix::              Fixing broken rec files, and diagnostics.

Conversion Utilities
* csv2rec::             Converting comma-separated-values data into
                          rec data.
* mdb2rec::             Converting mdb files into rec files.

* The Rec Library::     Writing C programs to manipulate rec files.
* Usage Example::       A full-fledged rec-based project management
                          system.
* GNU Free Documentation License:: Distribution terms for this document.
@end menu

@node Introduction
@chapter Introduction

XXX

@node A Little Example
@chapter A Little Example

Everyone loves to grow a nice book collection at home.  Unfortunately,
in most cases the management of our private books gets uncontrolled:
some books get lost, some of them may be loaned to some friend, there
are some duplicated (or even triplicated!) titles because we forgot
about the existence of the previous copy, and a large etc.

In order to improve the management of our little book collection we
could make use of a complex data storage system such as a relational
database.  The problem with that approach, as explained in the
previous section, is that the tool is too complicated for the simple
task: we do not need the full power of a RDBS to maintain a simple
collection of books.

With GNU recutils it is possible to maintain such a little database in
a text file.  Let's call it @file{books.rec}.  The following table
resumes the information items that we want to store for each title,
along with some common-sense restrictions.

@itemize @minus
@item
Every book has a title, even if it is ``No Title''.
@item
A book can have several titles.
@item
A book can have more than one author.
@item
Sometimes the author is not known.
@item
Sometimes we don't care about who the author of a book is.
@item
We usually store our books in home.
@item
We use to loan books to friends.
@item
Sometimes we are not sure about the physical location of a book.  Did
we loan it to someone?  Was it lost in the last move?  Is it in some
hidden place at home?
@end itemize

The contents of the rec file follows:

@example
# -*- mode: rec -*-

%rec: Book
%mandatory: Title
%doc:
+ A book in my personal collection.
+
+ The possible locations for a book are 'in site', 'loaned'
+ and 'unknown'.

Title: GNU Emacs Manual
Author: Richard M. Stallman
Publisher: FSF
Location: in site

Title: The Colour of Magic
Author: Terry Pratchett
Location: loaned
Contact:Name: Nicola Dinisio

Title: Mio Cid
Author: Anonymous
Location: in site

Title: chapters.gnu.org administration guide
Author: Nacho Gonzalez
Author: Jose E. Marchesi
Location: unknown

Title: Yeelong User Manual
Location: in site

# End of books.rec
@end example

Pretty clean and simple, huh?.  The file contains a set of records
separated by blank lines.  Each record is composed by a set of fields
with a name and a value.

The GNU record utilities can then be used to access the contents of
the file.  For example, we could get a list of the names of loaned
books invoking @command{recsel} in the following way:

@example
$ recsel -e "Location = 'loaned'" -P Title books.rec
The Colour of Magic
@end example

@node Fields and Records
@chapter Fields and Records

A field is the written form of an association between a label and a
value.  For example, if we wanted to associate the label @code{Name}
with the value @code{Ada Lovelace} we would write the field:

@example
Name: Ada Lovelace
@end example

The separator between the field name and the field value is a colon
followed by one or more blank characters (space and tabs, but not
newlines).  The name of the field shall begin in the first column of
the line.

A field name is a sequence of alphanumeric characters plus dashes
(@code{-}) and underscores (@code{_}), starting with a letter or the
character @code{%}.  The regular expression denoting a field name is:

@example
[a-zA-Z%][a-zA-Z0-9_-]+
@end example

Field names are case-sensitive.  @code{Foo} and @code{foo} are
considered different field names.

The following list contain valid field names (the final colon is
not part of the names):

@example
Foo:
foo:
A23:
ab1:
A_Field:
@end example

The value of a field is a sequence of characters terminated by a
single newline character (@code{\n}).

Sometimes a value is long enough to exceed the usual width of
terminals and screens.  In that case, depending on the specific tool
used to access the file, the readability of the data decreases.  It is
possible to physically split a logical line by escaping a newline with
a backslash character, as in:

@example
LongLine: This is a quite long value \
composed by a unique logical line \
split in several physical lines.
@end example

The sequence @code{\n} (newline) @code{+} (PLUS) and an optional
@code{_} (SPACE) is interpreted as a newline when found in a field
value.  For example, the C string @code{"bar1\nbar2\n bar3"} would be
encoded in the following way in a field value:

@example          
Foo: bar1
+ bar2
+  bar3
@end example

A record is a group of one or more fields written one after the other:

@example
Name1: Value1
Name2: Value2
Name2: Value3
@end example

It is possible for several fields in a record to share the same name
or/and the field value. The following is a valid record containing
three fields:

@example
Name: John Smith
Email: john.smith@@foomail.com
Email: john@@smith.name
@end example

The @dfn{size of a record} is defined as the number of fields
contained in that record.  There is no such like an empty record, so
the minimum size for a record is 1.  The maximum number of fields for
a record shall be considered as an implementation limit.  The size of
the previous record is 3.

Records are separated by one or more blank lines.  For instance, the
following example shows a file named @file{personalities.rec}
featuring three records:

@example
Name: Ada Lovelace
Age: 36

Name: Peter the Great
Age: 53

Name: Matusalen
Age: 969
@end example

@node Record Descriptors
@chapter Record Descriptors

It is possible to specify certain properties of a set of records by
preceding them by a @dfn{record descriptor}.  A record descriptor is
itself a record, and uses fields with specific names to store
properties.  The most basic property that can be specified for a set
of records is the @dfn{type} of the records.  The special field name
@code{%rec} is used for that purpose:

@example
%rec: Entry

Id: 1
Name: Entry 1

Id: 2
Name: Entry 2
@end example

The presence of another record descriptor mark the end of the
application of the previous one.  So, in a file with the following
structure:

@example
REC0

RECORD-DESCRIPTOR-1

REC1

REC2

RECORD-DESCRIPTOR-2

REC3

REC4
@end example

@code{REC0} is not described by any record descriptor.  The
@code{REC1} and @code{REC2} are described by
@code{RECORD-DESCRIPTOR-1} while @code{REC3} and @code{REC4} are
described by @code{RECORD-DESCRIPTOR-2}.

The record descriptor can contain the following fields:

@table @code
@item %rec
The value of this field is interpreted as the name of the kind of
record described by the record descriptor.  The string used as the
record type has the same restrictions that the field
names. @xref{Fields and Records}.

This field is unique.

It is highly recommended (but not enforced) to place this field in the
first position of the record descriptor.
@item %mandatory
The value of this field is interpreted as the name of a field, that
will be considered mandatory.

Its effect is that at least one field with this name should be present
in any record of this kind.  Any record violating this restriction
will be considered invalid.
@item %unique
The value of this field is interpreted as the name of a field, that
will be considered unique.

Its effect is that at much one field with this name should be present
in any record of this kind.  Any record violating this restriction
will be considered invalid.
@item %key
The value of this field is interpreted as the name of a field, that
will be considered as part of the key.

Its effect is that any field with that name is both unique and
mandatory, and additionally the values of those fields shall be
unique. 
@item %doc
This field contains documentation about the record.

It is like a comment, but this field can be managed in a programmatic
way easier.
@item %type
This field can be used to define types for fields.  @ref{Field Types}.

@item %order
This field can be used to define the preferred order of the fields in
the record.  Its usage is:

@example
%order: @var{field_name1} @var{field_name2} ... @var{field_nameN}
@end example

Where the field names are separated by one or more blank characters.
Example:

@example
%order: Id Name Email
@end example
@end table

@node Compound Field Names
@chapter Compound Field Names

It is possible to make a reference to a record (or set of records) of
a certain type by using a @dfn{compound field name}.  A compound field
is composed by three components separated by double colon characters
(@code{:}):

@example
TYPE:FIELD[:ROLE]:
@end example

The first component is a record type, usually defined somewhere else
(@pxref{Record Descriptors}). The second component is the name of a
field.  Finally, an optional third component is the role played by the
referenced field in the referencing record.

The simplest kind of reference is one without an explicit role.  It is
used when only one association between records of different types is
desired.  Consider for example:

@example
%rec: Maintainer

Name: Jose E. Marchesi
Package:Name: recutils
@end example

In the previous example it is pretty clear which role is played by the
referenced package in the @code{Maintainer} record: it is the package
maintained by the maintainer.  But sometimes the role is not that
identifiable.  Consider the following record:

@example
%rec: Bug

Id: 203
Title: recsel crashes with files bigger than 2gb
Hacker:Name: John Smith
@end example

Seems to be a bug report.  But, what is the relationship between John
Smith and the bug? Is he the reporter?  Or perhaps he is the hacker
that is working to fix it?  Or is he the hacker that closed the bug?
We can clarify the role of John Smith by using the third part of the
compound field:

@example
Id: 203
Title: recsel crashes with files bigger than 2gb
Hacker:Name:Reporter: John Smith
@end example

It is possible to make references to different instances of the same
record type by using roles.  Supposing that we want to record who is
the assignee of the bug report, we can introduce the new role
@code{Assignee}:

@example
Id: 203
Title: recsel crashes with files bigger than 2gb
Hacker:Name:Reporter: John Smith
Hacker:Name:Assignee: Juan Valdes 
@end example

Note that, like in the case of regular fields, there can be several
compound fields with the same name and the same implicit role in a
record, like in:

@example
%rec: Maintainer

Name: Jose E. Marchesi
Package:Name: GNU PDF
Package:Name: GNU Ferret
Package:Name: GNU rec
@end example

@node Comments
@chapter Comments

A line starting with a @code{#} (ASCII 0x23) character in the first
column is a comment line.

Comment lines are quite useful to insert additional information that
is not part of the database but useful otherwise.

It is useful to comment-out information from the rec file without
having to remove it in a definitive way: you may want to recover the
data into the database later!  Comment lines can be used to
comment-out either full registers and single fields:

@example
Name: Jose E. Marchesi
# Occupation: Software Engineer
# Severe lack of brain capacity
# Fired on 02/01/2009 (without compensation)
Occupation: Unoccupied
@end example

Comments are also useful to make up headers, comment blocks and all
kind of markers:

@example
# -*- mode: rec -*-
#
# Bug.rec
#
# This file contains the Bugs database of the recutils
# project.
#
# Blah blah...

...

# End of Bug.rec
@end example

@include getdate.texi

@node Field Types
@chapter Field Types

It is possible to declare in a record descriptor that fields with a
given name shall contain values of a given type.  The syntax is:

@example
%type: @var{field_name} @var{type} @var{type_description}
@end example

@noindent
where @var{field_name} is the name of the fields feturing this type in
the current record set, @var{type} is the name of a supported field
type and @var{type_description} is additional information that varies
from type to type.

The following sections describe the supported types.

@menu
* Escalar types::       Numbers, ranges and boolean values.
* String types::        Lines, limited strings and regular
                          expressions. 
* Enumerated types::    Enumerations.
* Time related types::  Dates and times.
@end menu

@node Escalar types
@section Escalar types

XXX:

@example
%type: Id integer
%type: PercentComplete range 0..100
%type: Myreal real
%type: Yesno boolean
@end example

It is possible to omit the minimum index in ranges.  In that case it
is implicitly zero:

@example
%type: PercentComplete range 100
@end example

@node String types
@section String types

XXX:

@example
%type: Foo line
%type: Bar size 10
%type: Baz regexp /RE/
@end example

@node Enumerated types
@section Enumerated types

Fields of this type contain symbols taken from an enumeration.

The type is described by writing the sequence of symbols conforming
the enumeration:

@example
%type: Status enum NEW STARTED DONE CLOSED
%type: Day enum Monday Tuesday Wednesday Thursday Friday Saturday Sunday
@end example

The symbols are separated by blank characters (including newlines).
It is possible to specify a blank as part of a symbol by using single
quotes:

@c XXX: better example.
@example
%type: Title enum 'Mr. Doctor' 'Mrs. Doctor'
@end example

@node Time related types
@section Time related types

XXX:

@example
%type: Date date
@end example


@node Common Options
@chapter Common Options

Certain options are available in all of these programs.  Rather than
writing identical descriptions for each of the programs, they are
described here.

@table @samp
@item @w{@kbd{--version}}
Print the version number, then exit successfully.
@item @w{@kbd{--help}}
Print a help message, then exit successfully.
@item @w{@kbd{--}}
Delimit the option list.  Later arguments, if any, are treated as
operands even if they begin with @option{-}.  For example,
@end table

@menu
* Selection Expressions::  Selecting records of a database.
* Field Expressions::      Selecting fields of a record.
@end menu
      
@node Selection Expressions
@section Selection Expressions

@dfn{Selection expressions} (also known as a SEXs) are simple infix
expressions that can be applied to a record.  The result of the SEX is
typically interpreted as a Boolean value.

@menu
* SEX Operands::        Literal values, fields and sub-expressions.
* SEX Operators::       Arithmetic, logical and other operators.
* SEX Evaluation::      Selection expressions are like generators.
* SEX Examples::        Examples of selection expressions.
@end menu

@node SEX Operands
@subsection Operands

The supported operands are: numbers, strings, field names and
parenthesized expressions.

@subsubsection Numeric Literals

The supported numeric literals are integer numbers.  The usual sign
character @samp{-} is used to denote negative values.  Examples are:

@example
10000
0
-1342
@end example

Additional zeroes in the left of the number are allowed, so both
@samp{00} and @samp{0100} are legal integer literals.

@subsubsection String Literals

String values are delimited by the @code{'} character.  Examples are:

@example
'Hello.'
'The following example is the empty string.'
''
@end example

The @code{'} and @code{\n} characters can be part of a string if they
are escaped with a backslash, like in:

@example
'This string contains an apostrophe: \'.'
'This string is a\
multi lines string.'
@end example

@subsubsection Field Values

The value of a field value can be included in a selection expression
by writing its name.  The field name is replaced by a string
containing the field value.  The last colon character (@code{:}) of
the field name is optional.  Examples:

@example
Name
Email:
Hacker:Name:OpenedBy
@end example

It is possible to use the role part of a field if it is not empty.
So, for example, if we are searching for the issues opened by
@samp{John Smith} in a database of issues we could write:

@example
$ recsel -e "OpenedBy = 'John Smith'"
@end example

@noindent
instead of using the full field name:

@example
$ recsel -e "Hacker:Name:OpenedBy = 'John Smith'"
@end example

When the name of a field appears in an expression, the expression is
applied to all the fields in the record featuring that name.  So, for
example, the expression:

@example
Email ~ "\\.org"
@end example

Will match any record in which there is a field named @samp{Email}
whose value terminates in @samp{.org}.  If we are interested in the
value of some specific email, we can specify its relative position
into the containing record by using @dfn{subscripts}.  Consider, for
example:

@example
Email[0] ~ "\\.org"
@end example

@noindent
Will match for:

@example
Name: Mr. Foo
Email: foo@@foo.org
Email: mr.foo@@foo.com
@end example

@noindent
But not for:

@example
Name: Mr. Foo
Email: mr.foo@@foo.com
Email: foo@@foo.org
@end example

@subsubsection Parenthesized Expressions

Parenthesis characters (@code{(} and @code{)}) can be used to group
sub expressions in the usual way.

@node SEX Operators
@subsection Operators

The supported operators are arithmetic operators (addition,
subtraction, multiplication, division and modulus), logical operators,
string operators and field operators.

@subsubsection Arithmetic Operators

Arithmetic operators for addition (@code{+}), subtraction (@code{-}),
multiplication (@code{*}), integer division (@code{/}) and modulus
(@code{%}) are supported with their usual meanings.

These operators require either integer operands or string operands
whose value can be interpreted as an integer literal.

@subsubsection Boolean Operators

The boolean operators @strong{and} (@code{&&}), @strong{or}
(@code{||}) and  @strong{not} (@code{!}) are supported with the same
semantics as their C counterparts.

Like the arithmetic operators, the boolean operators expect integer
operands, and will try to convert any string operand to an integer
value.

@subsubsection Comparison Operators

The compare operators @strong{less than} (@code{<}), @strong{greater
than} (@code{>}), @strong{less than or equal} (@code{<=}),
@strong{greater than or equal} (@code{>=}), @strong{equal} (@code{=})
and @strong{unequal} (@code{!=}) are supported with their usual
meaning.

Strings can be compared with the equality operator (@code{=}).

The match operator (@code{~}) can be used to match a string with a
given regular expression.  The supported regexp syntax is described in
the GNU C library manual.

@subsubsection Field Operators

Field counters are replaced by the number of occurrences of a field
with the given name in the record.  For example:

@example
#Email
@end example

The previous expression is replaced with the number of fields named
@code{Email} in the record.  It can be zero if the record does not
have a field with that name.

@node SEX Evaluation
@subsection Evaluation of Selection Expressions

@node SEX Examples
@subsection Examples

@node Field Expressions
@section Field Expressions

@dfn{Field expressions} (also known as FEXs) are a way to select
fields of a record.

A FEX is composed by a sequence of @dfn{elements} separated by commas:

@example
ELEM_1,ELEM_2,...,ELEM_N
@end example

Each element makes a reference to one or more fields in a record
identified by a given name and an optional subscript:

@example
@var{Field_Name}[@var{min}..@var{max}]
@end example

@noindent
@var{min} and @var{max} are zero-based indexes.  It is possible to
refer to a field occupying a given position.  For example, consider
the following record:

@example
Name: Mr. Foo
Email: foo@@foo.com
Email: foo@@foo.org
Email: mr.foo@@foo.org
@end example

@noindent
We would select all the emails of the record with:

@example
Email
@end example

@noindent
The first email with:

@example
Email[0]
@end example

@noindent
The third email with:

@example
Email[2]
@end example

@noindent
The second and the third email with:

@example
Email[1..2]
@end example

And so on.  Note that a selection is an ordered set not allowing
duplicated values.  Thus, the field expression:

@example
Email[0],Name,Email
@end example

@noindent
is equivalent to

@example
Email[0],Name,Email[1..2]
@end example

@node recinf
@chapter recinf

@command{recinf} reads the given rec files (or the data in the
standard input if no file is specified) and prints information about
it.

@menu
* recinf Invocation::  Command line options.
@end menu

@node recinf Invocation
@section recinf Invocation

@command{recinf} reads the given rec files (or the data in the
standard input if no file is specified) and prints a resume of the
record types contained in the input.

Synopsis:

@example
recinf [OPTION]... [FILE]...
@end example

The default behavior of the tool is to emit a line per record type in
the input containing its name and the number of records of that type:

@example
$ recinf hackers.rec tasks.rec
25 Hacker
102 Task
@end example

If the input contains anonymous records, i.e. records that are before
the first record descriptor, the corresponding line resume won't have
a type name:

@example
$ recinf data.rec
10
@end example

In addition of the common options described earlier (@pxref{Common
Options}) the program accepts the following options.

@table @samp
@item -v
@itemx @w{@kbd{--verbose}}
Be verbose by printing all the record descriptors present in the file.
@item -n
@itemx @w{@kbd{--names-only}}
Output just the names of the record types found in the input.  If the
input is composed by anonymous records only then don't emit any
output.
@end table

@node recsel
@chapter recsel

@command{recsel} reads the given rec files (or the data in the
standard input if no file is specified) and prints out records (or
part of records) based in some criteria specified by the user.

@menu
* recsel Invocation::      Command line options.
* recsel Examples::        Examples of the usage of @command{recsel}.
@end menu

@node recsel Invocation
@section recsel Invocation

@command{recsel} searches rec files for records satisfying a certain
criteria.  Synopsis:

@example
recsel [OPTION]... [-n NUM | -e RECORD_EXPR] [-c | (-p|-P|-R) FIELD_EXPR] [FILE]...
@end example

In addition of the common options described earlier (@pxref{Common
Options}) the program accepts the following options.

The @dfn{selection options} are used to select a subset of
the records in the input.

@table @samp
@item -n @var{num}
Match the record occupying the @var{num}th position in its record
set.
@item -e @var{expr}
@itemx @w{@kbd{--expression}=@var{expr}}
A record selection expression (@pxref{Selection Expressions}).  Only
the records matched by the expression will get taken into account to
compute the output.
@item -t TYPE
@itemx @w{@kbd{--type}=@var{type}}
Select records of a given type only.
@end table

The @dfn{output options} are used to determine what information about
the selected records to display to the user, and how to display it.

@table @samp
@item -p @var{name_list}
@itemx @w{@kbd{--print}=@var{name_list}}
List of fields to print for each record.  @var{name_list} is a
list of field names separated by commas.  For example:
@example
-p Name,Email
@end example
means to print the Name and the Email of every matching record.

If this option is not specified then all the fields of the matching
records are printed in the standard output.
@item -P @var{name_list}
@itemx @w{@kbd{--print-values}=@var{name_list}}
Same than @samp{-p}, but print the values of the selected fields.
@item -R @var{name_list}
@itemx @w{@kbd{--print-row}=@var{name_list}}
Same than @samp{-P}, but print the values separated by single
spaces instead of newlines.
@item -c
@itemx @w{@kbd{--count}}
If this option is specified then recsel will print the number of
matching records instead of the records themselves.  This option is
incompatible with @option{-p}, @option{-P} and @option{-R}.
@end table

Some special @dfn{special options} are available to ease the
communication between the recutils and other programs, such as lisp
interpreters.

@table @samp
@item -S
@itemx @w{@kbd{--print-sexps}}
Print the data using sexps instead of rec format.
@end table

@node recsel Examples
@section recsel Examples

XXX

@example
$ recsel -e 'Name ~ Jo' foo.rec
@end example

Print the name of the partners of all the persons less than twenty:

@example
$ recsel -e 'Age < 20' -p Partner foo.rec
@end example

@node recins
@chapter recins

@command{recins} adds new records to a rec file or to rec data read
from the standard input.

@menu
* recins Invocation::     Command line options.
* recins Examples::       Examples of the usage of @command{recins}.
@end menu

@node recins Invocation
@section recins Invocation

@command{recins} adds new records to a rec file or to rec data read
from the standard input.  Synopsis:

@example
recins [OPTION]... [-f STR -v STR]... [FILE]
@end example

The new record that will be inserted by the command is constructed by
using pairs of @samp{-f} and @samp{-v} options.  Each pair defines a
field.  The order of the parameters is significant.

In addition to the common options described earlier (@pxref{Common
Options}) the program accepts the following options.

@table @samp
@item -t
@itemx @w{@kbd{--type}=@var{expr}}
The type of the new record.  If there is a record set in the input
data matching this type then the new record is added there.  Otherwise
a new record set is created.  If this parameter is not specified then
the new record is anonymous.
@item -f
@itemx @w{@kbd{--field}=@var{name}}
Declares the name of a field.  This option shall be followed by a
@samp{-v}.
@item -v
@itemx @w{@kbd{--value}=@var{value}}
The value of the field being defined.
@end table

@node recins Examples
@section recins Examples

XXX

@node recdel
@chapter recdel

XXX

@node recset
@chapter recset

XXX

@node recfix
@chapter recfix

XXX

@node csv2rec
@chapter csv2rec

@command{csv2rec} reads the given comma-separated-values file (or the
data in the standard input if no file is specified) and prints out the
converted rec data, if possible.

@menu
* csv2rec Invocation::     Command line options.
* csv2rec Examples::       Examples of the usage of @command{csv2rec}.
@end menu

@node csv2rec Invocation
@section csv2rec Invocation

@command{csv2rec} converts CSV data into rec data.  Synopsis:

@example
csv2rec [OPTION]... [CSV_FILE]
@end example

In addition of the common options described earlier (@pxref{Common
Options}) the program accepts the following options.

@table @samp
@item -t @var{type}
@itemx @w{@kbd{--type}=@var{type}}
Type of the converted records.  If no type is specified then no type
is used.
@item -s
@itemx @w{@kbd{--strict}}
Be strict parsing the csv file.
@item -e
@itemx @w{@kbd{--omit-empty}}
Omit empty fields.
@end table

@node csv2rec Examples
@section csv2rec Examples

XXX

@node mdb2rec
@chapter mdb2rec

@command{mdb2rec} reads the given mdb file and prints out the
converted rec data, if possible.

@menu
* mdb2rec Invocation::      Command line options.
* mdb2rec Examples::        Examples of the usage of @command{mdb2rec}.
@end menu

@node mdb2rec Invocation
@section mdb2rec Invocation

@command{mdb2rec} converts mdb files into rec data.  Synopsis:

@example
mdb2rec [OPTION]... MDB_FILE [TABLE]
@end example

All the tables contained in the mdb file are exported unless a table
is specified in the command line.

In addition of the common options described earlier (@pxref{Common
Options}) the program accepts the following options.

@table @samp
@item -s
@itemx @w{@kbd{--system-tables}}
Include system tables in the output.
@item -l
@itemx @w{@kbd{--list-tables}}
Dump a list of the table names contained in the mdb file, one per
line.
@item -e
@itemx @w{@kbd{--keep-empty-fields}}
Don't prune empty fields in the rec output.
@end table

@node mdb2rec Examples
@section mdb2rec Examples

Access files (@dfn{mdb files}) are collections of several relations,
also known as tables.  Tables can be either @dfn{user tables} storing
user data, or @dfn{system tables} storing information such as forms,
queries or the relationships between the tables.

It is possible to get a listing with the names of all tables stored in
a mdb file by calling @command{mdb2rec} in the following way:

@example
$ mdb2rec -l sales.mdb
Customers
Products
Orders
@end example

So @file{sales.mdb} stores user information in the tables Customers,
Products and Orders.  If we want to include system tables in the
listing we can use the @kbd{-s} command line option:

@example
$ mdb2rec -s -l sales.mdb
MSysObjects
MSysACEs
MSysQueries
MSysRelationships
Customers
Products
Orders
@end example

The tables with names starting with @command{MSys} are system tables.
The data stored in those tables is either not relevant to the recutils
user (used by the Access program to create forms and the like) or is
used in an indirect way by @command{mdb2rec} (such as the information
from MSysRelationships).

Let's read some data from the @file{mdb} file.  We can get the
relation of Products in rec format:

@example
$ mdb2rec sales.mdb Products
%rec: Products
%type: ProductID int
%type: ProductName size 80
%type: Discontinued bool

ProductID: 1
ProductName: GNU generation T-shirt
Discontinued: 0

...
@end example

A @dfn{record descriptor} is created for the record set containing the
generated records, called Products.  Note that @command{mdb2rec} is
able to generate type information for the fields.  The list of
customers is similar:

@example
$ mdb2rec sales.mdb Customers
%rec: Customers
%type: CustomerID size 4
%type: CompanyName size 80
%type: ContactName size 60

CustomerID: GSOFT
CompanyName: GNU Soft
ContactName: Jose E. Marchesi

...
@end example

The list of orders is a bit more interesting, since it shows how
@command{mdb2rec} manages the relationships between tables in the
@file{mdb} file.

@example
$ mdb2rec sales.mdb Orders
%rec: Orders
%type: OrderID int
%type: CustomerID size 10
%type: ProductID int
%type: OrderDate date

OrderID: 10248
Customers:CustomerID: FBFOU
Product:ProductID: 1
OrderDate: 2010-08-01T12:30:01

...
@end example

Both CustomerID and ProductID are compound fields reflecting
references to the record sets Customers and Products.

Note that @command{mdb2rec} always uses the default role when the name
of the column in the referring table is the same than the name of the
column in the referred table.  This is to avoid redundant compound
field names like Customers:CustomerID:CustomerID:.

If no table is specified in the invocation to @command{mdb2rec} all
the tables in the file are processed, with the exception of the system
tables, for which @kbd{-s} shall be used:

@example
$ mdb2rec sales.mdb
%rec: Products
...

%rec: Customers
...

%rec: Orders
...
@end example

@node The Rec Library
@chapter The Rec Library

XXX

@node Usage Example
@chapter Usage Example

This chapter contains a complete description of a use-case for rec
files: the management of the data associated with a free software
project called @dfn{GNU Foo}.

@menu
* The GNU Foo Project::         Introduction to GNU Foo.
* Managing Contributors::       Hackers contributing to GNU Foo.
* Managing Tasks::              Foo.
* Managing Patches::            Foo.
* Legal Papers::                Foo.
@end menu

@node The GNU Foo Project
@section The GNU Foo Project

The main purpose of the GNU Foo project is to provide a full-fledged
free implementation of the @dfn{foo} format.  The software
distribution of GNU Foo consist in a shared library called
@code{libgnufoo} and a bunch of command line utilities.

@node Managing Contributors
@section Managing Contributors

The record descriptor for the hackers is:

@example
%rec: Hacker
%key: Email
%doc:
+ Contributor to GNU Foo.
@end example

@example
Name: John Smith
Email: john@@smith.name
Role: Developer
Papers: no
Wiki: yes
Flyspray: no
@end example

@node Managing Tasks
@section Managing Tasks

XXX

@example
%rec: Task
%doc:
+ Task of the GNU foo project.

Id: 203
Title: Update to autoconf 2.64
Description:
+ Both libfoo and footool source trees shall be updated to support
+ autoconf 2.64.
+
+ Obsolete macros shall be replaced by the recommended ones.  Backward
+ compatibility with previous versions of autoconf is not a must.
Status: closed
@end example

@node Managing Patches
@section Managing Patches

XXX

@example
%rec: Patch
%doc:
+ Patch sent to the GNU foo project.

Id: 1
Description:
+ Update to use autoconf 2.64.  A couple of obsolete macros are
+ substituted with their replacements.
Hacker:Name: John Smith
Task:Id: 203
Applied: no
Date: 2009-03-22

Id: 2
Description:
+ Implementation of the fluzo capacitor.
Hacker:Name: Juan Valdes
Applied: yes
Date: 2008-11-02
@end example

@node Legal Papers
@section Legal Papers

XXX

@node GNU Free Documentation License
@appendix GNU Free Documentation License

@include fdl.texi

@bye
