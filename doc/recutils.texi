\input texinfo
@comment %**start of header
@setfilename recutils.info
@include version.texi
@settitle GNU Recutils
@afourpaper
@comment %**end of header

@copying
This manual is for GNU recutils (version @value{VERSION},
@value{UPDATED}).

Copyright @copyright{} 2009, 2010, 2011, 2012 Jose E. Marchesi

Copyright @copyright{} 1994-2012 Free Software Foundation, Inc.

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with no
Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts. A
copy of the license is included in the section entitled ``GNU Free
Documentation License''.
@end quotation
@end copying

@dircategory Database
@direntry
* recutils: (recutils). The GNU Recutils manual.
@end direntry

@dircategory Individual utilities
@direntry
* recinf: (recutils)recinf.                    Get info about recfiles.
* recsel: (recutils)recsel.                    Read records.
* recins: (recutils)recins.                    Insert records.
* recdel: (recutils)recdel.                    Delete records.
* recset: (recutils)recset.                    Manage fields.
* recfix: (recutils)recfix.                    Fix recfiles.
* csv2rec: (recutils)csv2rec.                  CSV to recfiles.
* rec2csv: (recutils)rec2csv.                  Recfiles to CSV.
* mdb2rec: (recutils)mdb2rec.                  MDB to recfiles.
@end direntry

@titlepage
@title GNU recutils
@subtitle for version @value{VERSION}, @value{UPDATED}
@author GNU recutils Developers (@email{bug-recutils@@gnu.org})
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@contents

@ifnottex
@node Top
@top GNU Recutils

This manual documents version @value{VERSION} of the GNU recutils.

@insertcopying
@end ifnottex

@menu
Overview
* Introduction::        Introducing the GNU recutils.
* A Little Example::    Recutils in action.

The Basic Rec Format
* Fields and Records::  The basic structures conforming Rec files.
* Comments::            Comments are useful to store meta data.
* Record Descriptors::  Describing different types of records.

Special Fields
* %rec::                External and remote descriptors.
* %mandatory and %prohibit:: Requiring or forbidding specific fields.
* %unique and %key::    Working with keys.
* %doc::                Documenting your database.
* %typedef and %type::  Field types.
* %auto::               Auto counters and time-stamps.
* %sort::               Keeping your record sets sorted.
* %size::               Restricting the size of your database.
* %constraint::         Setting arbitrary constraints.
* %confidential::       Storing confidential information.

Advanced Topics and Reference
* Date input formats::  Textual date representations that can be used
                          in Rec files.
* Regular Expressions:: Flavor of regexps supported in recfiles.

The Recutils
* Common Options::      Common command line arguments for the record
                          utilities.
* recinf::              Printing information about rec files.
* recsel::              Selecting records.
* recins::              Inserting records.
* recdel::              Deleting records.
* recset::              Managing fields.
* recfix::              Fixing broken rec files, and diagnostics.
* recfmt::              Formatting records using templates.
* csv2rec::             Converting csv data into rec data.
* rec2csv::             Converting rec data into csv data.
* mdb2rec::             Converting mdb files into rec files.

* GNU Free Documentation License:: Distribution terms for this document.
@end menu

@node Introduction
@chapter Introduction

GNU recutils is a set of tools and libraries to access human-editable,
text-based databases called @emph{recfiles}.  The data is stored as a
sequence of records, each record containing an arbitrary number of
named fields.  Advanced capabilities usually found in other data
storage systems are supported: data types, data integrity (keys,
mandatory fields, etc) as well as the ability of records to refer to
other records (sort of foreign keys).  Despite its simplicity,
recfiles can be used to store medium-sized databases.

So, yet another data storage system?  The mere existence of this
package deserves an explanation.  There is a rich set of already
available free data storage systems, covering a broad range of
requirements.  Big systems having complex data storage requirements
will probably make use of some full-fledged relational system such as
MySQL or PostgreSQL.  Less demanding applications, or applications
with special deployment requirements, may find it more convenient to
use a simpler system such as SQLite, where the data is stored in a
single binary file.  XML files are often used to store configuration
settings for programs, and to encode data to be transmitted through
networks.

So it looks like all the needs are covered by the existing
solutions@dots{} but consider the following characteristics of the
data storage systems mentioned in the previous paragraph:

@table @minus
@item The stored data is not directly readable by humans.
@item The stored data is definitely not directly writable by humans.
@item They are program dependent.
@item They are not easily managed by version control systems.
@end table

Regarding the first point (human readability), while it is clearly
true for the binary files, some may argue XML files are indeed human
readable@dots{} well@dots{} <bar><foo tag=''val''>try</foo> to r&iamp;ead
<p>this</p></bar>.  YAML @footnote{Yet Another Markup Language} is an
example of a hierarchical data storage format which is much more
readable than XML.  The problem with YAML is that it was designed as a
``data serialization language'' and thus to map the data constructs
usually found in programming languages.  That makes it too complex for
the simple task of storing plain lists of items.

Recfiles are human-readable, human-writable and still they are easy to
parse and to manipulate automatically.  Obviously they are not
suitable for any task (for example, it can be difficult to manage
hierarchies in recfiles) and performance is somewhat sacrificed in
favor of readability.  But they are quite handy to store small to
medium simple databases.

The GNU recutils suite comprises:

@itemize @minus
@item This Texinfo manual, describing the Rec format and the accompanying software.
@item A C library (librec) that provides a rich set of functions to manipulate rec data.
@item A set of C utilities (recinf, recsel, recins, recdel, recset and  recfix) that can be used in shell scripts and in the command line to operate on rec files.
@item An emacs mode, @code{rec-mode}.
@end itemize

@node A Little Example
@chapter A Little Example

Everyone loves to grow a nice book collection at home.  Unfortunately,
in most cases the management of our private books gets uncontrolled:
some books get lost, some of them may be loaned to some friend, there
are some duplicated (or even triplicated!) titles because we forgot
about the existence of the previous copy, and many more details.

In order to improve the management of our little book collection we
could make use of a complex data storage system such as a relational
database.  The problem with that approach, as explained in the
previous section, is that the tool is too complicated for the simple
task: we do not need the full power of a relational database system to
maintain a simple collection of books.

With GNU recutils it is possible to maintain such a little database in
a text file.  Let's call it @file{books.rec}.  The following table
resumes the information items that we want to store for each title,
along with some common-sense restrictions.

@itemize @minus
@item
Every book has a title, even if it is ``No Title''.
@item
A book can have several titles.
@item
A book can have more than one author.
@item
Sometimes the author is not known.
@item
Sometimes we don't care about who the author of a book is.
@item
We usually store our books at home.
@item
We use to loan books to friends.
@item
On occasions we loose track to the physical location of a book.  Did
we loan it to anyone?  Was it lost in the last move?  Is it in some
hidden place at home?
@end itemize

@noindent
The contents of the rec file follows:

@example
# -*- mode: rec -*-

%rec: Book
%mandatory: Title
%type: Location enum loaned home unknown
%doc:
+ A book in my personal collection.

Title: GNU Emacs Manual
Author: Richard M. Stallman
Publisher: FSF
Location: home

Title: The Colour of Magic
Author: Terry Pratchett
Location: loaned

Title: Mio Cid
Author: Anonymous
Location: home

Title: chapters.gnu.org administration guide
Author: Nacho Gonzalez
Author: Jose E. Marchesi
Location: unknown

Title: Yeelong User Manual
Location: home

# End of books.rec
@end example

Simple.  The file contains a set of records separated by blank lines.
Each record is composed by a set of fields with a name and a value.

The GNU recutils can then be used to access the contents of the file.
For example, we could get a list of the names of loaned books by invoking
@command{recsel} in the following way:

@example
$ recsel -e "Location = 'loaned'" -P Title books.rec
The Colour of Magic
@end example

@node Fields and Records
@chapter Fields and Records

A @dfn{field} is the written form of an association between a label
and a value.  For example, if we wanted to associate the label
@code{Name} with the value @code{Ada Lovelace} we would write:

@example
Name: Ada Lovelace
@end example

The separator between the field name and the field value is a colon
followed by a blank character (space and tabs, but not newlines).  The
name of the field shall begin in the first column of the line.

A @dfn{field name} is a sequence of alphanumeric characters plus
dashes (@code{-}) and underscores (@code{_}), starting with a letter
or the character @code{%}.  The regular expression denoting a field
name is:

@example
[a-zA-Z%][a-zA-Z0-9_-]+
@end example

Field names are case-sensitive.  @code{Foo} and @code{foo} are
different field names.

The following list contains valid field names (the final colon is not
part of the names):

@example
Foo:
foo:
A23:
ab1:
A_Field:
@end example

The @dfn{value of a field} is a sequence of characters terminated by a
single newline character (@code{\n}).

Sometimes a value is too long to fit in the usual width of terminals
and screens.  In that case, depending on the specific tool used to
access the file, the readability of the data would not be that good.
It is therefore possible to physically split a logical line by
escaping a newline with a backslash character, as in:

@example
LongLine: This is a quite long value \
composed by a unique logical line \
split in several physical lines.
@end example

The sequence @code{\n} (newline) @code{+} (PLUS) and an optional
@code{_} (SPACE) is interpreted as a newline when found in a field
value.  For example, the C string @code{"bar1\nbar2\n bar3"} would be
encoded in the following way in a field value:

@example          
Foo: bar1
+ bar2
+  bar3
@end example

A @dfn{record} is a group of one or more fields written one after the
other:

@example
Name1: Value1
Name2: Value2
Name2: Value3
@end example

It is possible for several fields in a record to share the same name
or/and the field value. The following is a valid record containing
three fields:

@example
Name: John Smith
Email: john.smith@@foomail.com
Email: john@@smith.name
@end example

The @dfn{size of a record} is defined as the number of fields that it
contains.  A record cannot be empty, so the minimum size
for a record is 1.  The maximum number of fields for a record is only
limited by the available physical resources.  The size of the previous
record is 3.

Records are separated by one or more blank lines.  For instance, the
following example shows a file named @file{personalities.rec}
featuring three records:

@example
Name: Ada Lovelace
Age: 36

Name: Peter the Great
Age: 53

Name: Matusalem
Age: 969
@end example

@node Comments
@chapter Comments

Any line having an @code{#} (ASCII 0x23) character in the first column
is a comment line.

Comment lines are quite useful to insert additional information that
is not part of the database but useful otherwise.

It is also quite convenient to comment-out information from the
recfile without having to remove it in a definitive way: you may want
to recover the data into the database later!  Comment lines can be
used to comment-out both full registers and single fields:

@example
Name: Jose E. Marchesi
# Occupation: Software Engineer
# Severe lack of brain capacity
# Fired on 02/01/2009 (without compensation)
Occupation: Unoccupied
@end example

Comments are also useful for headers, footers, comment blocks and all
kind of markers:

@example
# -*- mode: rec -*-
#
# TODO
#
# This file contains the Bugs database of GNU recutils.
#
# Blah blah@dots{}

@dots{}

# End of TODO
@end example

@node Record Descriptors
@chapter Record Descriptors

Certain properties of a set of records can be specified by preceding
them with a @dfn{record descriptor}.  A record descriptor is itself a
record, and uses fields with some predefined names to store the
properties.  The most basic property that can be specified for a set
of records is their @dfn{type}.  The special field name @code{%rec} is
used for that purpose:

@example
%rec: Entry

Id: 1
Name: Entry 1

Id: 2
Name: Entry 2
@end example

The records following the descriptors are then identified as having
its type.  So in the example above we would say there are two records
of type ``Entry''.

The effect of a record descriptor ends when another descriptor is
found in the stream of records.  This allows to store different kind
of records in the same database.  For example, consider you have to
maintain a depot.  You will need to keep records of both the current
stockage and the movements.

The following example shows the usage of two record descriptors to
store both kind of records: articles and movements.

@example
%rec: Article

Id: 1
Title: Article 1

Id: 2
Title: Article 2

%rec: Movement

Id: 1
Type: sell
Date: 20 April 2011

Id: 2
Type: adquisition
Date: 21 April 2011
@end example

Besides determining the type of the records that follows in the
stream, record descriptors can be used to describe other properties of
those records.  That can be done by using the so-called @dfn{special
fields}, having special names from a predefined set.  Consider for
example the following database, where the descriptor is used to
specify a primary key and a mandatory field:

@example
%rec: Item
%key: Id
%mandatory: Title

Id: 10
Title: Notebook (big)

Id: 11
Title: Fountain Pen
@end example

Note that the names of special fields always start with the character
@code{%}.  Also note that it is also possible to use non-special
fields in a record descriptor, but such fields will have no effect on
the described record set.

What follows is an exhaustive list of the supported special fields.
They are discussed in deep in the following sections.

@table @code
@item %rec
Used to name the type of a set of records and to mark record
descriptors.
@item %mandatory
@item %prohibit
Those special fields are used to control which fields can and cannot
be included in records.
@item %unique
@item %key
Used to specify unique fields and primary keys.
@item %auto
Used to automatically generate certain fields when creating new
records, like auto counter and time-stamps.
@item %doc
Used to describe the contents of a record set.
@item %typedef
@item %type
Used to define named types and to associated types with fields.
@item %sort
Used to keep your records sorted by some given fields.
@item %size
Used to control the dimensions of a record set.
@item %confidential
Used to store confidential information.
@end table

@node %rec
@chapter %rec

The @code{%rec} special field is used for two main purposes: to
identify a record as a record descriptor, and to provide a name for
the described record set.  The synopsis of the usage of the field is
the following:

@example
%rec: @var{type} [@var{url_or_file}]
@end example

@noindent
@var{type} is the name of the kind of records described by the
descriptor.  It is mandatory to specify it, and it follows the same
lexical conventions used by field names.  @xref{Fields and Records}.
There is a non-enforced convention to use singular nouns, because the
name makes reference to the type of a single entity, even if it
applies to all the records contained in the record set.  For example,
the following record set contains transactions, and the type specified
in the record descriptor is @code{Transaction}.

@example
%rec: Transaction

Id: 10
Title: House rent

Id: 11
Title: Loan
@end example

@noindent
Only one @code{%rec} field shall appear in a record descriptor.  If
there are more it is an integrity violation.  It is highly
recommended (but not enforced) to place this field in the first
position of the record descriptor.

Sometimes it is convenient to store records of the same type in
different files.  The duplication of record descriptors in this case
would surely lead to consistency problems.  A possible solution would
be to keep the record descriptor in a separated file and then include
it in any operation by using pipes.  For example:

@example
$ cat descriptor.rec data.rec | recsel @dots{}
@end example

@noindent
For those cases it is more convenient to use a @dfn{external
descriptor}.  External descriptors can be built appending a file path
to the @code{%rec} field value, like:

@example
%rec: FSD_Entry /path/to/file.rec
@end example

The previous example indicates that a record descriptor describing the
@code{FSD_Entry} records shall be read from the file
@file{/path/to/file.rec}.  A record descriptor for @code{FSD_Entry}
may not exist in the external file.  Both relative and absolute paths
can be specified there.

URLs can be used as sources for external descriptors as well. In that
case we talk about @dfn{remote descriptors}.  For example:

@example
%rec: Department http://www.myorg.com/Org.rec
@end example

@noindent
The URL shall point to a text file containing rec data.  If there is a
record descriptor in the remote file documenting the @code{Department}
type, it will be used.

Note that the local record descriptor can provide additional fields to
``expand'' the record type.  For example:

@example
%rec: FSD_Entry http://www.jemarch.net/downloads/FSD.rec
%mandatory: Rating
@end example

@noindent
The record descriptor above is including the contents of the
@code{FSD_Entry} record descriptor from the URL, and adding them to
the local record descriptor, that in this case contains just the
@code{%mandatory} field.

If you are using the GNU recutils to process your recfiles, any URL
schema supported by @code{libcurl} will work.

@node %mandatory and %prohibit
@chapter %mandatory and %prohibit

Those special field names are used to restrict the fields that can
appear in the records stored in a database.  Their usage is:

@example
%mandatory: @var{field1} @var{field2} @dots{} @var{fieldN}
%prohibit: @var{field1} @var{field2} @dots{} @var{fieldN}
@end example

@noindent
In both cases the list of field names are separated by one or more
blank characters.

The fields listed in some @code{%mandatory} entry are
mandatory; i.e.@:, at least one field with this name shall be present
in any record of this kind.  Records violating this restriction are
invalid and a checking tool will report the situation as
a data integrity failure.

Consider for example an ``addressbook'' database where each record
stores the information associated with a contact.  The records will be
heterogeneous, in the sense they won't feature exactly the same
fields: the contact of an internet shop will probably have an
@code{Url} field, while the entry for our grandmother probably won't.
We still want to make sure that every entry has at a field: the name
of the contact.  In that case we could use @code{%mandatory} as
follows:

@example
%rec: Contact
%mandatory: Name

Name: Granny
Phone: +12 23456677

Name: Yoyodyne Corp.
Email: sales@@yoyod.com
Phone: +98 43434433
@end example

@noindent
Similarly, the fields listed in some @code{%prohibit} entry are
forbidden; i.e.@:, no field with this name shall be present
in any record of this kind.  Again, records violating this restriction
are invalid.

This can be useful when some field name is reserved for some future
use.  For example, if we want to make sure no @code{Telex} will ever
be used in our contacts database, we would change the record
descriptor as follows:

@example
%rec: Contact
%mandatory: Name
%prohibit: Telex
@end example

@noindent
Several @code{%mandatory} and/or @code{%prohibit} fields can appear in
the same record descriptor.  The set of mandatory or prohibited fields
is the union of all the entries.  For example, in the following
database both @code{Id} and @code{id} are prohibited:

@example
%rec: Entry
%prohibit: Id
%prohibit: id
@end example

@node %unique and %key
@chapter %unique and %key

These special field names are used to avoid several instances of the
same field in a record, and to implement keys in record sets.  Their
usage is:

@example
%unique: @var{field1} @var{field2} @dots{} @var{fieldN}
%key: @var{field}
@end example

@noindent
The list of field names are separated by one or more blank characters.

The @code{%unique} special field allows one to declare fields as unique,
meaning there cannot exist more than one field with the same name in a
single record.

For example, an entry in an addressbook database could contain an
@code{Age} field.  It does not make sense for a single person to be of
several ages, so that field could be declared as ``unique'' in the
corresponding record descriptor as follows:

@example
%rec: Contact
%mandatory: Name
%unique: Age
@end example

@noindent
Several @code{%unique} fields can appear in the same record
descriptor.  The set of unique fields is the union of all the entries.

@code{%key} makes the referred field the primary key of the record
set.  Its effect is that any field with that name must be both unique
and mandatory, and additionally the values of those fields shall be
unique in the context of the record set.  This closely corresponds to
the notion of ``primary key'' usually implemented in relational
systems.

Consider for example a database of items in a stockage.  Each item is
identified by a numerical @code{Id} field.  No item may have more than
one @code{Id}, and no items may exist without an associated
@code{Id}.  Additionally, no two items may share the same @code{Id}.
This common situation can be implementing by declaring @code{Id} as
the key in the record descriptor:

@example
%rec: Item
%key: Id
%mandatory: Title

Id: 1
Title: Box

Id: 2
Title: Sticker big
@end example

@noindent
It would not make sense to have several primary keys in a record set,
and thus it is not allowed to have several @code{%key} fields in the
same record descriptor.  That is a data integrity
violation and will be reported by a checking tool.

@node %doc
@chapter %doc

This field contains documentation about the record.

It is like a comment, but this field can be managed in a programmatic
way easier.

@node %typedef and %type
@chapter %typedef and %type

Field values are, by default, unrestricted text strings.  However, it
is often useful to impose some restrictions on the values of certain
fields.  For example, consider the following record:

@example
Id: 111
Name: Jose E. Marchesi
Age: 30
MaritalStatus: single
Phone: +49 666 666 66
@end example

Where @code{Id} is a numeric identifier for a person. @code{Name} will
never use several lines. @code{Age} will typically be in the range
@code{0..120}, and there are only a few valid values for
@code{MaritalStatus}: single, married and widow.  Phones may be
restricted to some standard format as well to be valid.  All those
restrictions (and many others) can be enforced by using @dfn{field
types}.

There are two kind of field types: @dfn{anonymous} and @dfn{named}.  Those are
described in the following subsections.

@menu
* Declaring types::     Declaration of types in record descriptors.
* Types and fields::    Associating fields with types.
* Escalar types::       Numbers and ranges.
* String types::        Lines, limited strings and regular expressions. 
* Enumerated types::    Enumerations and boolean values.
* Time related types::  Dates and times.
* Other types::         Emails, fields, UUIDs, @dots{}
@end menu

@node Declaring types
@section Declaring types

A type can be declared in a record descriptor by using the
@code{%typedef} special field.  The syntax is:

@example
%typedef: @var{type_name} @var{type_description}
@end example

@noindent
Where @var{type_name} is the name of the new type, and
@var{type_description} a description which varies depending of the
kind of type.  For example, this is how a type @code{Age_t} could
be defined as numbers in the range @code{0..120}:

@example
%typedef: Age_t range 0 120
@end example

@noindent
Type names are identifiers having the following syntax:

@example
[a-zA-Z][a-zA-Z0-9_-]*
@end example

@noindent
Even though any identifier with that syntax could be used for types,
it is a good idea to consistently follow some convention to help
distinguishing type names from field names.  For example, the
@code{_t} suffix could be used for types.

A type can be declared to be a synonym of another type.  The syntax
is:

@example
%typedef: @var{type_name} @var{other_type_name}
@end example

@noindent
Where @var{type_name} is declared to be a synonym of
@var{other_type_name}.  This is useful to avoid duplicated type
descriptions.  For example, consider the following example:

@example
%typedef: Id_t          int
%typedef: Item_t        Id_t
%typedef: Transaction_t Id_t
@end example

@noindent
Both @code{Item_t} and @code{Transaction_t} are synonyms for the type
@code{Id_t}.  They are both numeric identifiers.

The order of the @code{%typedef} fields is not relevant.  In
particular, a type definition can reference other type that is defined
below.  The previous example could have been written as:

@example
%typedef: Item_t        Id_t
%typedef: Transaction_t Id_t
%typedef: Id_t          int
@end example

@noindent
Integrity checks will complain if undefined types are referenced, and
if there are loops (direct or indirect) in type declarations.  For
example, the following set of declarations contains a loop and are
thus invalid:

@example
%typedef: A_t B_t
%typedef: B_t C_t
%typedef: C_t A_t
@end example

@noindent
The scope of a type is the record descriptor where it is defined.

@node Types and fields
@section Types and fields

Fields can be declared to have a given type by using the @code{%type}
special field in a record descriptor.  The synopsis is:

@example
%type: @var{field_list} @var{type_name_or_description}
@end example

@noindent
Where @var{field_list} is a list of field names separated by
commas.  @var{type_name_or_description} can be either a type name
declared with @code{%typedef}, or a type description.  Type names are
useful when several fields are declared to be of the same type:

@example
%typedef: Id_t    int
%type:    Id      Id_t
%type:    Product Id_t
@end example

@noindent
Anonymous types can be used by writing a type description instead of a
type name.  They help to avoid superfluous type declarations.  A
record containing a single @code{Id} field, for example, can be defined
without having to use a @code{%typedef} in the following way:

@example
%rec: Task
%type: Id int
@end example

@node Escalar types
@section Escalar types

The rec format supports the declaration of fields of the following
escalar types: integer numbers, ranges and reals.

Signed @dfn{integers} are supported by using the @code{integer}
declaration:

@example
%typedef: Id_t int
@end example

@noindent
Given that declaration, Fields of type @code{Id_t} must contain
integers, that may be negative.  Hexadecimal values can be written
using the @code{0x} prefix, and octal values use an extra
@code{0}. Valid examples are:

@example
%type: Id Id_t

Id: 100
Id: -23
Id: -0xFF
Id: 020
@end example

@noindent
Sometimes it is desirable to reduce the @dfn{range} of integers allowed in a
field.  That can be achieved by using a range type declaration:

@example
%typedef: Percentage_t range 0 100
@end example

@noindent
Note that it is possible to omit the minimum index in ranges.  In that
case it is implicitly zero:

@example
%typedef: Percentage_t range 100
@end example

@noindent
Hexadecimal and octal numbers can be used to specify the limits in a
range.  This helps to define scalar types whose natural base is not
ten, like for example:

@example
%typedef: Address_t range 0x0000 0xFFFF
%typedef: Perms_t range 755
@end example

@noindent
@dfn{Real} fields can be declared with the @code{real} type specifier.
A wide range of real numbers can be represented this way, only limited
by the underlying floating point representation.  For example:

@example
%typedef: Longitude_t real
@end example

@noindent
Examples of fields of type real:

@example
%rec: Rectangle
%typedef: Longitude_t real
%type: Width  Longitude_t
%type: Height Longitude_t

Width: 25.01
Height: 10
@end example

@node String types
@section String types

The @code{line} field type specifier can be used to restrict the value
of a field to a single line, i.e.@: no newline characters are allowed.
For example, a type for proper names could be declared as:

@example
%typedef: Name_t line
@end example

@noindent
Examples of fields of type line:

@example
Name: Mr. Foo Bar
Name: Mss. Bar Baz
Name: This is
+ invalid
@end example

@noindent
Sometimes it is the maximum size of the field value that shall be
restricted.  The @code{size} field type specifier can be used to
define the maximum number of characters a field value can have.  For
example, if we were collecting input that will get written in a
paper-based forms system allowing up to 25 characters width entries,
we could declare the entries as:

@example
%typedef: Address_t size 25
@end example

@noindent
Note that hexadecimal and octal integer constants can also be used to
specify field sizes:

@example
%typedef: Address_t size 0x18
@end example

@noindent
Arbitrary restrictions can be defined by using regular expressions.
The @dfn{regexp} field type specifier introduces an ERE (extended
regular expression) that will be matched against fields having that
name.  The synopsis is:

@example
%typedef: @var{type_name} regexp /@var{re}/
@end example

@noindent
where @var{re} is the regular expression to match.

For example, consider the @code{Id_t} type designed to represent
the encoding of the identifier of ID cards in some country:

@example
%typedef: Id_t regexp /[0-9]@{9@}[a-zA-Z]/
@end example

@noindent
Examples of fields of type @code{Id_t} are:

@example
IDCard: 123456789Z
IDCard: invalid id card
@end example

@noindent
Note that the slashes delimiting the @var{re} can be replaced with
any other character that is not itself used as part of the regexp.
That is useful in some cases such as:

@example
%typedef: Path_t regexp |(/[^/]/?)+|
@end example

@noindent
The regexp flavor supported in recfiles are the POSIX EREs plus
several GNU extensions.  @xref{Regular Expressions}.

@node Enumerated types
@section Enumerated types

Fields of this type contain symbols taken from an enumeration.

The type is described by writing the sequence of symbols comprising
the enumeration.  Enumeration symbols are strings described by the
following regexp:

@example
[a-zA-Z0-9][a-zA-Z0-9_-]*
@end example

@noindent
The symbols are separated by blank characters (including newlines).
For example:

@example
%typedef: Status_t enum NEW STARTED DONE CLOSED
%typedef: Day_t enum Monday Tuesday Wednesday Thursday Friday
+                    Saturday Sunday
@end example

@noindent
It is possible to insert comments when describing an enum type.  The
comments are delimited by parenthesis pairs.  The contents of the
comments can be any character but parentheses.  For example:

@example
%typedef: TaskStatus_t enum
+ NEW         (The task was just created)
+ IN_PROGRESS (Task started)
+ CLOSED      (Task closed)
@end example

@noindent
@dfn{Boolean} fields can be seen as special enumerations holding the
binary values.

@example
%typedef: Yesno_t bool
@end example

@noindent
The literals allowed in boolean fields are @code{yes/no}, @code{0/1}
and @code{true/false}.  Examples are:

@example
SwitchedOn: 1
SwitchedOn: yes
SwitchedOn: false
@end example

@node Time related types
@section Time related types

The @dfn{Date} field type specifier can be used to declare dates and
times.  The synopsis is:

@example
%typedef: @var{type_name} date
@end example

@noindent
The several date/time syntax supported by librec is provided by the
@code{date} module from gnulib.  @xref{Date input formats}.

@node Other types
@section Other types

The @dfn{Email} field type specifier is used to declare electronic
addresses such as emails.  The synopsis is:

@example
%typedef: Email_t email
@end example

@noindent
Sometimes it is useful to make fields to store field names.  For that
purpose the @dfn{Field} field type specifier is supported.  The
synopsis is:

@example
%typedef: Field_t field
@end example

@noindent
Universally Unique Identifiers (also known as UUIDs) are a way to
assign a globally unique label to some object.  The @dfn{uuid} field
type specifier serves that purpose.  The synopsis is:

@example
%typedef: Id_t uuid
@end example

@noindent
The format of the uuids is conformed by 32 hexadecimal digits,
displayed in 5 groups separated by hyphens. For example:

@example
550e8400-e29b-41d4-a716-446655440000
@end example

@noindent
The @dfn{rec} field type is used to support the notion of @dfn{foreign
key} in the recutils world.  It is used to denote the fact that a
field is referring some record stored in another record set.  For
example:

@example
%typedef: Maintainer_t rec Hacker
@end example

@noindent
The previous example defines the type @code{Maintainer_t} which is of
type ``record @code{Hacker}''.  This basically means that the values
to be stored in fields of type @code{Maintainer_t} are of whatever
type defined for the primary key of the @code{Hacker} record set.

@node %auto
@chapter %auto

This special field allows to include auto-generated fields in our
databases.  Its usage is:

@example
%auto: @var{field1} @var{field2} @dots{} @var{fieldN}
@end example

@noindent
The list of field names are separated by one or more blank characters.
There can be several @code{%auto} fields in the same record
descriptor, the effective list of auto-generated fields being the
union of all the entries.

Auto generated fields are a very useful facility usually provided by
database implementations.  Consider for example a list of articles in
stock in a toys store:

@example
%rec: Item
%key: Description

Description: 2cm metal soldier WWII
Amount: 2111

Description: Flying Helicopter Indoor Maxi
Amount: 8

@dots{}
@end example

It would be natural to identify the items by its description, but it
is also error prone: was it ``Flying Helicopter Indoor Maxi'' or
``Flying Helicopter Maxi Indoor''? Was ``Helicopter'' in lower case or
upper case?

It is quite common in databases to use some kind of numeric ``Id'' to
uniquely identify items like those ones.  That is because numbers are
easy to operate with, and to increase.   So we could add a new
numeric @code{Id} field and use it as the primary key:

@example
%rec: Item
%key: Id
%mandatory: Description

Id: 0
Description: 2cm metal soldier WWII
Amount: 2111

Id: 1
Description: Flying Helicopter Indoor Maxi
Amount: 8

@dots{}
@end example

A problem of this approach is that we must be careful to not assign
already used ids when we introduce more articles in the
database. Other than its uniqueness, it is not important which number
is associated with which article.

To ease the management of those Ids database systems use to provide a
facility called ``auto-counters''. Auto-counters can be implemented in
recfiles using the @code{%auto} directive in the record descriptor:

@example
%rec: Item
%key: Id
%type: Id int
%mandatory: Description
%auto: Id

Id: 0
Description: 2cm metal soldier WWII
Amount: 2111
@end example

Next time a new item is introduced in the database, the conforming
application will note the @code{%auto}, and will create a new
@code{Id} field for the new record with the bigger unused integer
available.  In this example, the new record will have an Id of
@code{1}.  The application can still provide an explicit Id for the
new record.  In that case the field is not generated automatically.

The concrete effect of the @code{%auto} directive depends on the type
of the affected field:

@itemize @minus
@item If it is an @code{integer} or a @code{range} then the biggest non-used number in the record set will be generated.
@item If it is a @code{date} then a field with the current date will be generated.
@item If it is a @code{uuid} then a new time-based uuid will be generated.
@item If no explicit type is defined for an auto generated field it is assumed to be an integer.
@item Auto generated fields with other types are not allowed.
@end itemize

Auto generated dates can be used to implement automatic timestamps.
Consider for example a ``Transfer'' record set registering bank
transfers.  We want to save a timestamp every time a transfer is done,
so we include an @code{%auto} for the date:

@example
%rec: Transfer
%key: Id
%type: Id int
%type: Date date
%auto: Id Date
@end example

Note that the auto fields are generated at the beginning of the new
records, in the same order they are found in the @code{%auto}
directives.

@node %sort
@chapter %sort

This special field allows to set sorting criteria for the records
contained in a record set.  Its usage is:

@example
%sort: @var{field1} @var{field2} ...
@end example

@noindent
Meaning that the desired order for the records will be determined by
the contents of the fields named in the @code{%sort} value.  The
sorting is always done in ascending order, and there may be records
not featuring the involved fields, it is not mandatory for the sorting
fields to be mandatory :D.

It is an error to have more than one @code{%sort} field in the same
record descriptor, as only one field list can be used as sorting
criteria.

Consider for example that we want to keep the records in our stockage
system ordered by entry date.  We could achieve that by using the
following record descriptor in the database:

@example
%rec: Item
%type: Date date
%sort: Date

Id: 1
Title: Staplers
Date: 10 February 2011

Id: 2
Title: Ruler Pack 20
Date: 2 March 2009

@dots{}
@end example

@noindent
As you can see in the example above, the fact we use @code{%sort} in a
database does not mean that the database will be always physically
ordered.  Unsorted record sets are not a data integrity
problem, and thus the diagnosis tools must not declare a recfile as
invalid because of this.  Some tools may provide a way to physically
order the fields in the file.  That is certainly the case of the GNU
recutils, where @command{recfix} can be used for that purpose.
@xref{recfix}.

On the other hand any program listing, presenting or processing data
extracted from the recfile must honor the @code{%sort} entry.  For
example, when using the following @command{recsel} program in the
database above we would get the output sorted by date:

@example
$ recsel stockage.rec
Id: 2
Title: Ruler Pack 20
Date: 2 March 2009

Id: 1
Title: Staplers
Date: 10 February 2011
@end example

@noindent
The sorting of the selected field depends on its type:

@itemize @minus
@item Numeric fields (integers, ranges, reals) are numerically ordered.
@item Boolean fields are ordered considering that ``false'' values come first.
@item Dates are ordered chronologically.
@item Any other kind of field is ordered using a lexicographic order.
@end itemize

It is possible to specify several fields as the sorting criteria.  In
that case the records are sorted using a lexicographic order.  Consider
for example the following unsorted database containing marks for
several students:

@example
%rec: Marks
%type: Class enum A B C
%type: Score real

Name: Mr. One
Class: C
Score: 6.8

Name: Mr. Two
Class: A
Score: 6.8

Name: Mr. Three
Class: B
Score: 9.2

Name: Mr. Four
Class: A
Score: 2.1

Name: Mr. Five
Class: C
Score: 4
@end example

If we wanted to sort it by @code{Class} and by @code{Score} we would
insert a @code{%sort} special field in the descriptor, having:

@example
%rec: Marks
%type: Class enum A B C
%type: Score real
%sort: Class Score

Name: Mr. Four
Class: A
Score: 2.1

Name: Mr. Two
Class: A
Score: 6.8

Name: Mr. Three
Class: B
Score: 9.2

Name: Mr. Five
Class: C
Score: 4

Name: Mr. One
Class: C
Score: 6.8
@end example

Note that the order of the fields in the @code{%sort} field is
significant.  If we reverse the order in the example above then we get
a different sorted set:

@example
%rec: Marks
%type: Class enum A B C
%type: Score real
%sort: Score Class

Name: Mr. Four
Class: A
Score: 2.1

Name: Mr. Five
Class: C
Score: 4

Name: Mr. Two
Class: A
Score: 6.8

Name: Mr. One
Class: C
Score: 6.8

Name: Mr. Three
Class: B
Score: 9.2
@end example

In this last case, Mr. One comes after Mr. Two because the class A
comes before the class B even if they got the same score (@code{6.8}).

@node %size
@chapter %size

The @code{%size} special field is used to define constraints in the
number of records stored in a record set.  Its usage is:

@example
%size: [@var{relational_operator}] @var{number}
@end example

@noindent
If no operator is specified then @var{number} is interpreted as the
exact number of records of this type.  The number can be any integer
literal, including hexadecimal and octal constants.  For example:

@example
%rec: Day
%size: 7
%type: Name enum
+ Monday Tuesday Wednesday Thursday Friday
+ Saturday Sunday
%doc: There should be 7 days.
@end example

The optional @var{relational_operator} shall be one of @code{<},
@code{<=}, @code{>} and @code{>=}.  For example:

@example
%rec: Item
%key: Id
%size: <= 100
%doc: We have at most 100 different articles.
@end example

It is valid to specify a size of @code{0}, meaning that no records of
this type shall exist in the file.

This field shall appear only once in a record descriptor.

@node %constraint
@chapter %constraint

The @code{%constraint} special field is used to define constraints
based on selection expressions.  Its usage is:

@example
%constraint: @var{expr}
@end example

@noindent
where @var{expr} is a selection expression.  When a constraint is
present in a record set it means that all the records of that type
must satisfy the selection expression, i.e. the evaluation of the
expression with the record returns 1.  Otherwise an integrity error is
raised.

Consider for example a record type @code{Task} featuring two fields of
type date called @code{Start} and @code{End}.  We can use a constraint
in the record set to specify that the task cannot start after it
finishes:

@example
%rec: Task
%type: Start,End date
%constraint: Start << End
@end example

The ``implies'' operator @code{=>} is specially useful when defining
constraints, since it allows to specify conditional constraints.  For
example, we could specify that if a task is closed then it must have
an @code{End} date in the following way:

@example
%rec: Task
%type: Start,End date
%constraint: Start << End
%constraint: Status = 'CLOSED' => #End
@end example

Note that it is acceptable to declare several constraints in the same record
set.

@node %confidential
@chapter %confidential

This special field allows to declare a set of fields as
@dfn{confidential}, meaning they contain sensitive information such as
passwords or secrets.  Its usage is:

@example
%confidential: @var{field1} @var{field2} @dots{} @var{fieldN}
@end example

@noindent
The list of field names are separated by one or more blank characters.
There can be several @code{%confidential} fields in the same record
descriptor, the effective list of confidential fields being the union
of all the entries.

Declaring a field as confidential indicates that its contents must not
be stored in plain text, but encrypted with a password-based
mechanism.  When the information is retrieved from the database the
confidential fields are unencrypted if the correct password is
provided.  Likewise, when information is inserted in the database the
confidential fields are encrypted with some given password.

For example, consider a database of users of some service.  For each
user we want to store a name, a login name, an email address and a
password.  All this information is public with the obvious exception
of the password.  Thus we declare the @code{Password} field as
confidential in the corresponding record descriptor:

@example
%rec: Account
%type: Name line
%type: Login line
%type: Email email
%confidential: Password
@end example

The rec format does not impose the usage of a specific encryption
algorithm, but requires that:

@itemize @minus
@item The algorithm must be password-based.
@item The value of any encrypted field shall begin with the string
@code{encrypted-} followed by the encrypted data.
@item The encrypted data must be encoded in some ASCII encoding such
as base64.
@end itemize

The above rules assure that it is possible to determine whether a
given field is encrypted.  For example, the following is an excerpt
from the account database described above.  It contains an entry with
the password encrypted and another with the password unencrypted:

@example
Name: Mr. Foo
Login: foo
Email: foo@@foo.com
Password: encrypted-AAABBBCCDDDEEEFFF

Name: Mr. Bar
Login: bar
Email: bar@@bar.com
Password: secret
@end example

Unencrypted confidential fields are a data integrity error,
and utilities like @code{recfix} will report it.  The same utility can
be used to ``fix'' the database by massively encrypting any
unencrypted field.

Nothing prevents the usage of several passwords in the same database.
This allows the establishment of several level of securities or
security profiles.  For example, we may want to store different
passwords for different online services:

@example
%rec: Account
%confidential: WebPassword ShellPassword
@end example

@noindent
We could then encrypt WebPassword entries using a password shared
among all the webmasters, and the ShellPassword entries with a more
restricted password available only to the administrator of the
machine.

The GNU recutils fully support encrypted fields.  See the documentation
for @code{recsel}, @code{recins} and @code{recfix} for details on how
to operate on files containing confidential fields.

@include parse-datetime.texi

@node Regular Expressions
@chapter Regular Expressions

The character @samp{.} matches any single character except the null character.

@table @samp

@item +
indicates that the regular expression should match one or more occurrences of the previous atom or regexp.
@item ?
indicates that the regular expression should match zero or one occurrence of the previous atom or regexp.
@item \+
matches a @samp{+}
@item \?
matches a @samp{?}.
@end table


Bracket expressions are used to match ranges of characters.  Bracket expressions where the range is backward, for example @samp{[z-a]}, are invalid.  Within square brackets, @samp{\} is taken literally.  Character classes are supported; for example @samp{[[:digit:]]} will match a single decimal digit.

GNU extensions are supported:
@enumerate

@item @samp{\w} matches a character within a word

@item @samp{\W} matches a character which is not within a word

@item @samp{\<} matches the beginning of a word

@item @samp{\>} matches the end of a word

@item @samp{\b} matches a word boundary

@item @samp{\B} matches characters which are not a word boundary

@item @samp{\`} matches the beginning of the whole input

@item @samp{\'} matches the end of the whole input

@end enumerate

Grouping is performed with parentheses @samp{()}.  An unmatched
@samp{)} matches just itself.  A backslash followed by a digit acts as
a back-reference and matches the same thing as the previous grouped
expression indicated by that number.  For example @samp{\2} matches
the second group expression.  The order of group expressions is
determined by the position of their opening parenthesis @samp{(}.

The alternation operator is @samp{|}.

The characters @samp{^} and @samp{$} always represent the beginning
and end of a string respectively, except within square brackets.
Within brackets, @samp{^} can be used to invert the membership of the
character class being specified.

@samp{*}, @samp{+} and @samp{?} are special at any point in a regular
expression except the following places, where they are not allowed:
@enumerate

@item At the beginning of a regular expression

@item After an open-group, signified by
@samp{(}
@item After the alternation operator @samp{|}

@end enumerate


Intervals are specified by @samp{@{} and @samp{@}}.  Invalid intervals
such as @samp{a@{1z} are not accepted.

The longest possible match is returned; this applies to the regular
expression as a whole and (subject to this constraint) to
sub-expressions within groups.

@node Common Options
@chapter Common Options

Certain options are available in all of these programs.  Rather than
writing identical descriptions for each of the programs, they are
described here.

@table @samp
@item @w{@kbd{--version}}
Print the version number, then exit successfully.
@item @w{@kbd{--help}}
Print a help message, then exit successfully.
@item @w{@kbd{--}}
Delimit the option list.  Later arguments, if any, are treated as
operands even if they begin with @option{-}.  For example,
@code{recsel -- -p} reads from the file named @file{-p}.
@end table

@menu
* Selection Expressions::  Selecting records of a database.
* Field Expressions::      Selecting fields of a record.
@end menu
      
@node Selection Expressions
@section Selection Expressions

@dfn{Selection expressions} (also known as a SEXs) are simple infix
expressions that can be applied to a record.  The result of the SEX is
typically interpreted as a Boolean value.

@menu
* SEX Operands::        Literal values, fields and sub-expressions.
* SEX Operators::       Arithmetic, logical and other operators.
* SEX Evaluation::      Selection expressions are like generators.
@end menu

@node SEX Operands
@subsection Operands

The supported operands are: numbers, strings, field names and
parenthesized expressions.

@subsubsection Numeric Literals

The supported numeric literals are integer numbers and real numbers.
The usual sign character @samp{-} is used to denote negative values.
Integer values can be denoted in base 10, base 16 using the @code{0x}
prefix, and base 8 using the @code{0} prefix.  Examples are:

@example
10000
0
0xFF
-0xa
012
-07
-1342
.12
-3.14
@end example

@subsubsection String Literals

String values are delimited by either the @code{'} character or the
@code{"} character.  Whatever delimiter is used, the delimiter closing
the literal shall equal to the delimiter used to open it.

Note that newlines and tabs can be part of a string literal.

Examples are:

@example
'Hello.'
'The following example is the empty string.'
''
@end example

The @code{'} and @code{"} characters can be part of a string if they
are escaped with a backslash, like in:

@example
'This string contains an apostrophe: \'.'
"This one a double quote: \"."
@end example

@subsubsection Field Values

The value of a field value can be included in a selection expression
by writing its name.  The field name is replaced by a string
containing the field value, covering any possibility with records with
more than one field featuring that name.  Examples:

@example
Name
Email
long_field_name
@end example

It is possible to use the role part of a field if it is not empty.
So, for example, if we are searching for the issues opened by
@samp{John Smith} in a database of issues we could write:

@example
$ recsel -e "OpenedBy = 'John Smith'"
@end example

@noindent
instead of using the full field name:

@example
$ recsel -e "Hacker:Name:OpenedBy = 'John Smith'"
@end example

When the name of a field appears in an expression, the expression is
applied to all the fields in the record featuring that name.  So, for
example, the expression:

@example
Email ~ "\\.org"
@end example

@noindent
Will match any record in which there is a field named @samp{Email}
whose value terminates in @samp{.org}.  If we are interested in the
value of some specific email, we can specify its relative position
into the containing record by using @dfn{subscripts}.  Consider, for
example:

@example
Email[0] ~ "\\.org"
@end example

@noindent
Will match for:

@example
Name: Mr. Foo
Email: foo@@foo.org
Email: mr.foo@@foo.com
@end example

@noindent
But not for:

@example
Name: Mr. Foo
Email: mr.foo@@foo.com
Email: foo@@foo.org
@end example

The regexp flavor supported in selection expressions are the POSIX
EREs plus several GNU extensions.  @xref{Regular Expressions}.

@subsubsection Parenthesized Expressions

Parenthesis characters (@code{(} and @code{)}) can be used to group
sub expressions in the usual way.

@node SEX Operators
@subsection Operators

The supported operators are arithmetic operators (addition,
subtraction, multiplication, division and modulus), logical operators,
string operators and field operators.

@subsubsection Arithmetic Operators

Arithmetic operators for addition (@code{+}), subtraction (@code{-}),
multiplication (@code{*}), integer division (@code{/}) and modulus
(@code{%}) are supported with their usual meanings.

These operators require either numeric operands or string operands
whose value can be interpreted as numbers (integer or real).

@subsubsection Boolean Operators

The boolean operators @strong{and} (@code{&&}), @strong{or}
(@code{||}) and  @strong{not} (@code{!}) are supported with the same
semantics as their C counterparts.

A compound boolean operator @code{=>} is also supported in order to
ease the elaboration of constraints in records.  @code{A => B}, which
can be read as ``A implies B'', translates into @code{!A || (A && B)}.

@example
A => B 
@end example


The boolean operators expect integer operands, and will try to convert
any string operand to an integer value.

@subsubsection Comparison Operators

The compare operators @strong{less than} (@code{<}), @strong{greater
than} (@code{>}), @strong{less than or equal} (@code{<=}),
@strong{greater than or equal} (@code{>=}), @strong{equal} (@code{=})
and @strong{unequal} (@code{!=}) are supported with their usual
meaning.

Strings can be compared with the equality operator (@code{=}).

The match operator (@code{~}) can be used to match a string with a
given regular expression.  The supported regexp syntax is described in
the GNU C library manual.

@subsubsection Date Comparison Operators

The compare operators @strong{before} (@code{<<}), @strong{after}
(@code{>>}) and @strong{same time} (@code{==}) can be used with fields
and strings containing parseable dates.

@xref{Date input formats}.

@subsubsection Field Operators

Field counters are replaced by the number of occurrences of a field
with the given name in the record.  For example:

@example
#Email
@end example

The previous expression is replaced with the number of fields named
@code{Email} in the record.  It can be zero if the record does not
have a field with that name.

@subsubsection String Operators

The string concatenation operator (@code{&}) can be used to
concatenate any number of strings and field values.

@example
'foo' & Name & 'bar'
@end example

@subsubsection Conditional Operator

The ternary conditional operator can be used to select alternatives
based on the value of some expression:

@example
expr1 ? expr2 : expr3
@end example

If @code{expr1} evaluates to true (i.e.@: it is an integer or the string
representation of an integer and its value is not zero) then the
operator yields @code{expr2}.  Otherwise it yields @code{expr3}.

@node SEX Evaluation
@subsection Evaluation of Selection Expressions

Given that:

@itemize @minus
@item It is possible to refer to fields by name in selection expressions.
@item Records can have several fields featuring the same name.
@end itemize

It is clear that some backtracking mechanism is needed in the
evaluation of the selection expressions.  For example, consider the
following expression that is deciding whether a ``registration'' in a
webpage shall be rejected:

@example
((Email ~ "foomail\.com") || (Age <= 18)) && !#Fixed
@end example

The previous expression will be evaluated for every possible
permutation of the fields ``Email'', ``Age'' and ``Fixed'' present in
the record, until one of the combinations succeeds.  At that point the
computation is interrupted.

When used to decide whether a record matches some criteria, the goal
of a selection expression is to act as a boolean expression.  In that
case the final value of the expression depends on both the type and
the value of the result launched by the top-most subexpression:

@itemize @minus
@item If the result is an @b{integer}, the expression is true if its
value is not zero.
@item If the result is a @b{real}, or a @b{string}, the expression
evaluates to false.
@end itemize

Sometimes a selection expression is used to compute a result instead
of a boolean.  In that case the returned value is converted to a
string.  This is used when replacing the slots in templates
(@pxref{recfmt Templates}).

@node Field Expressions
@section Field Expressions

@dfn{Field expressions} (also known as FEXs) are a way to select
fields of a record.  They also allow to do some transformations in the
selected fields, such as changing their names.

A FEX is composed by a sequence of @dfn{elements} separated by commas:

@example
ELEM_1,ELEM_2,@dots{},ELEM_N
@end example

Each element makes a reference to one or more fields in a record
identified by a given name and an optional subscript:

@example
@var{Field_Name}[@var{min}-@var{max}]
@end example

@noindent
@var{min} and @var{max} are zero-based indexes.  It is possible to
refer to a field occupying a given position.  For example, consider
the following record:

@example
Name: Mr. Foo
Email: foo@@foo.com
Email: foo@@foo.org
Email: mr.foo@@foo.org
@end example

@noindent
We would select all the emails of the record with:

@example
Email
@end example

@noindent
The first email with:

@example
Email[0]
@end example

@noindent
The third email with:

@example
Email[2]
@end example

@noindent
The second and the third email with:

@example
Email[1-2]
@end example

And so on.  Note that it is possible to select the same field (or
range of fields) more than once just by repeating them in a field
expression.  Thus, the field expression:

@example
Email[0],Name,Email
@end example

@noindent
will print the first email, the name, and then all the email fields
including the first one.

It is possible to include a @dfn{rewrite rule} in an element of a
field expression, which specifies an alias for the selected fields:

@example
@var{Field_Name}[@var{min}-@var{max}]:@var{Alias}
@end example

@noindent
For example, the following field expression specifies an alias for the
fields named @code{Email} in a record:

@example
Name,Email:ElectronicEmail
@end example

Since the rewrite rules only affect to the fields selected in a single
element of the field expression, it is possible to define different
aliases to several fields having the same name but occupying different
positions:

@example
Name,Email[0]:PrimaryEmail,Email[1]:SecondaryEmail
@end example

@noindent
When that field expression is applied to the following record:

@example
Name: Mr. Foo
Email: primary@@email.com
Email: secondary@@email.com
Email: other@@email.com
@end example

@noindent
the result will be:

@example
Name: Mr. Foo
PrimaryEmail: primary@@email.com
SecondaryEmail: secondary@@email.com
Email: other@@email.com
@end example

It is possible to use the dot notation in order to refer to field and
sub-fields.  This is mainly used in the context of joins, where new
fields are created having compound names such as @code{Foo_Bar}.  A
reference to such a field can be done in the fex using dot notation
like follows:

@example
Foo.Bar
@end example

@node recinf
@chapter recinf

@command{recinf} reads the given rec files (or the data in the
standard input if no file is specified) and prints information about
it.

@menu
* recinf Invocation::  Command line options.
@end menu

@node recinf Invocation
@section recinf Invocation

@command{recinf} reads the given rec files (or the data in the
standard input if no file is specified) and prints a resume of the
record types contained in the input.

Synopsis:

@example
recinf [@var{option}]@dots{} [@var{file}]@dots{}
@end example

The default behavior of the tool is to emit a line per record type in
the input containing its name and the number of records of that type:

@example
$ recinf hackers.rec tasks.rec
25 Hacker
102 Task
@end example

If the input contains anonymous records, i.e.@: records that are before
the first record descriptor, the corresponding line resume won't have
a type name:

@example
$ recinf data.rec
10
@end example

In addition of the common options described earlier (@pxref{Common
Options}) the program accepts the following options.

@table @samp
@item -t @var{type}
@itemx @w{@kbd{--type}=@var{type}}
Select records of a given type only.
@item -d
@itemx @w{@kbd{--descriptor}}
Print all the record descriptors present in the file.
@item -n
@itemx @w{@kbd{--names-only}}
Output just the names of the record types found in the input.  If the
input is composed by anonymous records only then don't emit any
output.
@item -S
@itemx @w{@kbd{--print-sexps}}
Print the data in the form of sexps (lisp expressions) instead of rec
format.  This option is intended to be used by lisp programs.
@end table

@node recsel
@chapter recsel

@command{recsel} reads the given rec files (or the data in the
standard input if no file is specified) and prints out records (or
part of records) based upon some criteria specified by the user.

@menu
* recsel Invocation::      Command line options.
* recsel Examples::        Examples of the usage of @command{recsel}.
* recsel Encryption::      Reading confidential data.
* recsel Grouping::        Grouping records by a given field.
@end menu

@node recsel Invocation
@section recsel Invocation

@command{recsel} searches rec files for records satisfying certain
criteria.  Synopsis:

@example
recsel [@var{option}]@dots{} [-n @var{indexes} | -e @var{record_expr} | -q @var{str} | -m @var{num}] [-c | (-p|-P|-R) @var{field_expr}] \
       [@var{file}]@dots{}
@end example

In addition of the common options described earlier (@pxref{Common
Options}) the program accepts the following options.

If no @var{file} is specified then the command acts like a filter, getting
the data from the standard input and writing the result in the
standard output.

@noindent
The following @dfn{global options} are available.

@table @samp
@item -i
@itemx @w{@kbd{--case-insensitive}}
Make strings case-insensitive in selection expressions.
@item -C
@item @w{@kbd{--collapse}}
Do not section the result in records with newlines.
@item -d
@itemx @w{@kbd{--include-descriptors}}
Print record descriptors along with the matched records
@item -s @var{secret}
@itemx @w{@kbd{--password}=@var{secret}}
Try to decrypt confidential fields with the given password.
@item -S
@itemx @w{@kbd{--sort}=@var{fields}}
Sort the output by the comma separated list of fields names
@var{fields}.  This option has precedence to whatever sorting criteria
is specified in the corresponding record descriptor with @code{%sort}.
@item -U
@itemx @w{@kbd{--uniq}}
Remove duplicated fields in the output records.  Fields are
duplicated if there are more than one featuring the same field name
and the same value.
@item -G
@itemx @w{@kbd{--group-by}=@var{fields}}
Group the output records by the provided comma separated set of
@var{fields}.  Note that grouping is performed before sorting.
@end table

The @dfn{selection options} are used to select a subset of
the records in the input.

@table @samp
@item -n @var{indexes}
@item @w{@kbd{--number}=@var{indexes}}
Match the records occupying the given positions in its record set.
@var{indexes} must be a comma-separated list of numbers or ranges, the
ranges being two numbers separated with dashes.  For example, the
following list denotes the first, the third, the fourth and all
records up to the tenth: @code{-n 0,2,4-9}.
@item -e @var{expr}
@itemx @w{@kbd{--expression}=@var{expr}}
A record selection expression (@pxref{Selection Expressions}).  Only
the records matched by the expression will be taken into account to
compute the output.
@item -q @var{str}
@itemx @w{@kbd{--quick}=@var{str}}
Select records having a field whose value contains the substring
@var{str}.
@item -m @var{num}
@itemx @w{@kbd{--random}=@var{num}}
Select @var{num} random records.  If @var{num} is zero then select all
the records. 
@item -t @var{type}
@itemx @w{@kbd{--type}=@var{type}}
Select records of a given type only.
@item -j @var{field}
@itemx @w{@kbd{--field}=@var{field}}
Perform an inner join of the record set selected in @option{-t} and
the record set for which @var{field} is a foreign key.  @var{field}
must be a field declared with type @code{rec} and thus must be a
foreign key.  If a join is performed then any selection expression and
field expression operate on the joined record sets.
@end table

The @dfn{output options} are used to determine what information about
the selected records to display to the user, and how to display it.

@table @samp
@item -p @var{name_list}
@itemx @w{@kbd{--print}=@var{name_list}}
List of fields to print for each record.  @var{name_list} is a
list of field names separated by commas.  For example:
@example
-p Name,Email
@end example

@noindent
means to print the Name and the Email of every matching record.

If this option is not specified then all the fields of the matching
records are printed in the standard output.
@item -P @var{name_list}
@itemx @w{@kbd{--print-values}=@var{name_list}}
Same than @samp{-p}, but print the values of the selected fields.
@item -R @var{name_list}
@itemx @w{@kbd{--print-row}=@var{name_list}}
Same than @samp{-P}, but print the values separated by single
spaces instead of newlines.
@item -c
@itemx @w{@kbd{--count}}
If this option is specified then recsel will print the number of
matching records instead of the records themselves.  This option is
incompatible with @option{-p}, @option{-P} and @option{-R}.
@end table

Some @dfn{special options} are available to ease the communication
between the recutils and other programs, such as lisp interpreters.
Those options are not intended to be used by human operators.

@table @samp
@itemx @w{@kbd{--print-sexps}}
Print the data using sexps instead of rec format.
@end table

@node recsel Examples
@section recsel Examples

Print the closed bugs:

@example
$ recsel -t Task -e "Status = 'CLOSED'" TODO.rec
@end example

Print the name of all the registrants less than twenty:

@example
$ recsel -e 'Age < 20' -P Partner registrants.rec
@end example

@node recsel Encryption
@section recsel Encryption

The contents of confidential fields can be read using the
@option{-s|--password} command line option to @command{recsel}.  When
used, any selected record containing encrypted fields will try to
decrypt them with the given password.  If the operation succeeds then
the output will include the unencrypted data.  Otherwise the
ASCII-encoded encrypted data will be emitted.

If @command{recsel} is invoked interactively and no password is
specified with @option{-s}, the user will be asked for a password in
case one is needed. No echo of the password will appear in the screen.
The provided password will be used to decrypt all confidential fields
as if it was specified with @option{-s}.

For example, consider the following database storing information about
the user accounts of some online service.  Each entry stores a login,
a full name, email and a password.  The password is declared as
confidential:

@example
%rec: Account
%key: Login
%confidential: Password

Login: foo
Name: Mr. Foo
Email: foo@@foo.com
Password: encrypted-AAABBBCCCDDD

Login: bar
Name: Ms. Bar
Email: bar@@bar.org
Password: encrypted-XXXYYYZZZUUU
@end example

@noindent
If we use @command{recsel} to get a list of records of type
@code{Account} without specifying a password, or if the wrong password
was specified in interactive mode, then we would get the following
output with the encrypted values:

@example
$ cat accounts.rec | recsel -t Account -p Login,Password
Login: foo
Password: encrypted-AAABBBCCCDDD

Login: bar
Password: encrypted-XXXYYYZZZUUU
@end example

@noindent
If we specify a password and both entries were encrypted using that
password, we would get the unencrypted values:

@example
$ recsel -t Account -s secret -p Login,Password accounts.rec
Login: foo
Password: foosecret

Login: bar
Password: barsecret
@end example

Note that nothing prevents to have confidential fields encrypted with
different passwords.  As discussed in @pxref{%confidential} this can
be useful to implement several ``levels'' of security.  For example,
we may have an entry in our database with data about the account of
the administrator of the online service.  In that case we could want
to store the password associated with that account using a
differentiated password.  In that case the output of the last command
would have been:

@example
$ recsel -t Account -s secret -p Login,Password accounts.rec
Login: foo
Password: foosecret

Login: bar
Password: barsecret

Login: admin
Password: encrypted-TTTVVVBBBNNN
@end example

@noindent
We would need to invoke @command{recsel} with the password used to
encrypt the admin entry in order to read it back unencrypted.

@node recsel Grouping
@section recsel Grouping

@dfn{Grouping} is an important technique used in relational databases,
always combined with aggregate functions.

Consider for example a relation of items in a shop stockage.  For each
item it is stored its type, its category, its price, the date of the
last selling operation of an item of that type, and the amount of
items currently available in stock.  A sample of such a database is
contained in the following table:

@multitable @columnfractions .08 .21 .21 .08 .21 .21
@item Id   @tab Type @tab Category @tab Price @tab LastSell @tab Available
@item 12   @tab EC Car @tab Toy @tab 12.2 @tab 20/April/2012 @tab 623
@item 16   @tab Terria Nat. @tab Food @tab 0.60 @tab 22/April/2012 @tab 8239
@item 17   @tab Typex @tab Office @tab 1.20 @tab 22/April/2012 @tab 10878
@item 19   @tab Notebook @tab Office @tab 1.00 @tab 21/April/2012 @tab 77455
@item 20   @tab Sexy Puzzle @tab Toy @tab 6.20 @tab 21/April/2012 @tab 12
@end multitable

The @acronym{SQL} aggregate functions can be applied to the totality
of the tuples in the relation.  For example, using the @code{Count}
aggregate function we can calculate the number of entries in the
relation as follows:

@example
> SELECT Count(Id) FROM Items
6
@end example

@noindent
Similarly, the average price of all the item types stored in the
stockage is obtained using the following query:

@example
> SELECT Average(Price) FROM Items
4.24
@end example

But, what if we are interested in some property of a subset of the
tuples in the relation?  SQL allows to partition the contents of a
relation in several ``groups'', using a list of fields which act as
the grouping criteria.

For example, if we wanted to group the contents of the @code{Items}
relation in groups of items of the same category, we would end with
the following ``sub-relations'':

@multitable @columnfractions .08 .21 .21 .08 .21 .21
@item Id   @tab Type @tab Category @tab Price @tab LastSell @tab Available
@item 12   @tab EC Car @tab Toy @tab 12.2 @tab 20/April/2012 @tab 623
@item 20   @tab Sexy Puzzle @tab Toy @tab 6.20 @tab 21/April/2012 @tab 12
@item ---- @tab ----        @tab ----@tab ---- @tab ----           @tab ----
@item 16   @tab Terria Nat. @tab Food @tab 0.60 @tab 22/April/2012 @tab 8239
@item ---- @tab ----        @tab ----@tab ---- @tab ----           @tab ----
@item 17   @tab Typex @tab Office @tab 1.20 @tab 22/April/2012 @tab 10878
@item 19   @tab Notebook @tab Office @tab 1.00 @tab 21/April/2012 @tab 77455
@end multitable

Aggregate functions can then be applied to the sub-relations.  For
example, the average prices of the several item categories stored in
the database, we would use the query:

@example
SELECT Category,Average(Price) FROM Items GROUP BY Category
@end example

@noindent
Obtaining the following result relation:

@multitable @columnfractions .10 .10
@item Toy    @tab 9.2
@item Food   @tab 0.60
@item Office @tab 1.1
@end multitable

Note that in most relational systems the query above is processed in
several differentiated steps:

@enumerate
@item A selection is performed in the relation using whatever
expression is specified in the @code{WHERE} part of the query.  In
this example no expression is used, so the selection result is the
whole relation.
@item The relation is partitioned using the list of fields specified
in the @code{GROUP BY} part of the query.  Note that the relational
paradigm does not support this notion of sub-relation.  Thus, the
partitioning is not something directly visible by the user of the
system.  It is just a temporary representation of the data.
@item A selection is performed in each partition using the expression
in the @code{HAVING} part of the query.  In this example no expression
is used.
@item Finally the @code{SELECT} part, which contains calls to
aggregate functions and the grouping fields, is executed for each
partition.
@end enumerate

@node recins
@chapter recins

@command{recins} adds new records to a rec file or to rec data read
from the standard input.

@menu
* recins Invocation::     Command line options.
* recins Examples::       Examples of the usage of @command{recins}.
* recins Encryption::     Inserting confidential fields in a database.
@end menu

@node recins Invocation
@section recins Invocation

@command{recins} adds new records to a rec file or to rec data read
from the standard input.  Synopsis:

@example
recins [@var{option}]@dots{} [t @var{type}] [-n @var{indexes} | -e @var{record_expr} | -q @var{str} | -m @var{num}] \
       [(-f @var{str} -v @var{str}]|[-r @var{recdata})]@dots{} [@var{file}]
@end example

The new record that will be inserted by the command is constructed by
using pairs of @samp{-f} and @samp{-v} options.  Each pair defines a
field.  The order of the parameters is significant.

If no @var{file} is specified then the command acts like a filter, getting
the data from the standard input and writing the result in the
standard output.

If the specified @var{file} does not exist, it is created.

In addition to the common options described earlier (@pxref{Common
Options}) the program accepts the following options.

@table @samp
@item -t
@itemx @w{@kbd{--type}=@var{expr}}
The type of the new record.  If there is a record set in the input
data matching this type then the new record is added there.  Otherwise
a new record set is created.  If this parameter is not specified then
the new record is anonymous.
@item -f
@itemx @w{@kbd{--field}=@var{name}}
Declares the name of a field.  This option shall be followed by a
@samp{-v}.
@item -v
@itemx @w{@kbd{--value}=@var{value}}
The value of the field being defined.
@item -r
@itemx @w{@kbd{--record}=@var{value}}
Add the fields of the record in @var{value}.  This option can be
intermixed with @kbd{-f @dots{} -v} pairs.
@item -s
@itemx @w{@kbd{--password}}
Encrypt confidential fields with the given password.
@itemx @w{@kbd{--no-external}}
Don't use external record descriptors.
@itemx @w{@kbd{--verbose}}
Be verbose when reporting integrity problems.
@itemx @w{@kbd{--no-auto}}
Don't generate @dfn{auto} fields. @xref{%auto}.
@end table

Record selection arguments are supported too.  If they are used
then @command{recins} enters ``replacement mode''.  Instead of
appending the new record, matched records are replaced by copies of
the provided record.  The selection arguments are summarized in the
next table.

@table @samp
@item -n @var{indexes}
@item @w{@kbd{--number}=@var{indexes}}
Match the records occupying the given positions in its record set.
@var{indexes} must be a comma-separated list of numbers or ranges, the
ranges being two numbers separated with dashes.  For example, the
following list denotes the first, the third, the fourth and all
records up to the tenth: @code{-n 0,2,4-9}.
@item -e @var{record_expr}
@itemx @w{@kbd{--expression}=@var{expr}}
A record selection expression (@pxref{Selection Expressions}).
Matching records will get replaced.
@item -q @var{str}
@itemx @w{@kbd{--quick}=@var{str}}
Remove records having a field whose value contains the substring
@var{str}.
@item -m @var{num}
@itemx @w{@kbd{--random}=@var{num}}
Select @var{num} random records.  If @var{num} is zero then all
records are selected, i.e. no replace mode is activated.
@item -i
@itemx @w{@kbd{--case-insensitive}}
Make strings case-insensitive in selection expressions.
@itemx @w{@kbd{--force}}
Insert the requested record even in potentially dangerous situations,
such as when the data integrity of the database is compromised.
@end table

@node recins Examples
@section recins Examples

Create a new issue in the bugs database:

@example
$ recins -t Task  -f Id     -v 10           \
                  -f Title  -v "New issue." \
                  -f Status -v NEW          \
         TODO.rec
@end example

Register a new event in a log file, using recins as a filter:

@example
recins -f Date -v `date` -f Entry -v "$HW_ADDR device connected" \
       < $LOG@var{file} > $LOG@var{file}.t \
  && cat $LOG@var{file}.t >> $LOG@var{file}
@end example

@node recins Encryption
@section recins Encryption

@command{recins} allows the insertion of encrypted fields in a
database.  When the @option{-s|--password} command line option is
specified in the command line any field declared as confidential in
the record descriptor will get encrypted using the given passphrase.
If the command is executed interactively and @option{-s} is not used
then the user is asked to provide a password using the terminal.  For
example, the invocation:

@example
$ recins -t Account -s mypassword -f Login -v foo -f Password -v secret accounts.rec
@end example

@noindent
Will encrypt the value of the @code{Password} field with
@code{mypassword} as long as the field is declared as confidential.
(@pxref{%confidential} for details on confidential fields).

@command{recins} will issue a warning if a confidential field is
inserted in the database but no password was provided to encrypt it.
This is to avoid having unencrypted sensitive data in the recfiles.

@node recdel
@chapter recdel

@command{recdel} removes records from a rec file, or from rec data
read from the standard input.

@menu
* recdel Invocation::     Command line options.
* recdel Examples::       Examples of the usage of @command{recdel}.
@end menu

@node recdel Invocation
@section recdel Invocation

@command{recdel} removes records from a rec file, or from rec data
read from the standard input.  Synopsis:

@example
recdel [OPTIONS]@dots{} [-t @var{type}] [-n @var{indexes} | -e @var{record_expr} | -q @var{str} | -m @var{num}] [@var{file}]
@end example

If no @var{file} is specified then the command acts like a filter,
getting the data from the standard input and writing the result in the
standard output.

In addition to the common options described earlier (@pxref{Common
Options}) the program accepts the following options.

@table @samp
@item -t
@itemx @w{@kbd{--type}=@var{expr}}
Remove records of the given type.  If this parameter is not specified
then records of any type will be removed.
@item -n @var{indexes}
@item @w{@kbd{--number}=@var{indexes}}
Match the records occupying the given positions in its record set.
@var{indexes} must be a comma-separated list of numbers or ranges, the
ranges being two numbers separated with dashes.  For example, the
following list denotes the first, the third, the fourth and all
records up to the tenth: @code{-n 0,2,4-9}.
@item -e @var{record_expr}
@itemx @w{@kbd{--expression}=@var{expr}}
A record selection expression (@pxref{Selection Expressions}).  Only
the records matched by the expression will be removed from the file.
@item -q @var{str}
@itemx @w{@kbd{--quick}=@var{str}}
Remove records having a field whose value contains the substring
@var{str}.
@item -m @var{num}
@itemx @w{@kbd{--random}=@var{num}}
Remove @var{num} random records.  If @var{num} is zero then remove all
the records.
@item -c
@itemx @w{@kbd{--comment}}
Comment the matching records out instead of removing them.
@itemx @w{@kbd{--force}}
Delete even in potentially dangerous situations, such as the request
to delete all the records of some type, for example.
@itemx @w{@kbd{--no-external}}
Don't use external record descriptors.
@item -i
@itemx @w{@kbd{--case-insensitive}}
Make strings case-insensitive in selection expressions.
@itemx @w{@kbd{--verbose}}
Be verbose when reporting integrity problems.
@end table

@node recdel Examples
@section recdel Examples

Comment out closed issues in the bugs database:

@example
$ recdel -c -t Task -e "Status = 'CLOSED'" TODO.rec
@end example

@node recset
@chapter recset

@command{recset} manipulates the fields of records in a rec file.

@menu
* recset Invocation::     Command line options.
* recset Examples::       Examples of the usage of @command{recset}.
@end menu

@node recset Invocation
@section recset Invocation

@command{recset} manipulates the fields of records in a rec file, or
rec data read from the standard input.  Synopsis:

@example
recset [@var{option}]@dots{} [@var{file}]@dots{}
@end example

If no @var{file} is specified then the command acts like a filter,
getting the data from the standard input and writing the result in the
standard output.

In addition to the common options described earlier (@pxref{Common
Options}) the program accepts the following options.

Record selection options:

@table @samp
@item -i
@itemx @w{@kbd{--case-insensitive}}
Make strings case-insensitive in selection expressions.
@item -t
@itemx @w{@kbd{--type}=@var{expr}}
Operate on the records of the given type.  If this parameter is not
specified then records of any type will be affected.
@item -n @var{indexes}
@item @w{@kbd{--number}=@var{indexes}}
Operate on the records occupying the given positions in its record
set.  @var{indexes} must be a comma-separated list of numbers or
ranges, the ranges being two numbers separated with dashes.  For
example, the following list denotes the first, the third, the fourth
and all records up to the tenth: @code{-n 0,2,4-9}.
@item -e @var{expr}
@itemx @w{@kbd{--expression}=@var{expr}}
A record selection expression (@pxref{Selection Expressions}).  Only
the records matched by the expression will be processed.
@item -q @var{str}
@itemx @w{@kbd{--quick}=@var{str}}
Operate on records having a field whose value contains the substring
@var{str}.
@item -m @var{num}
@itemx @w{@kbd{--random}=@var{num}}
Operate on @var{num} random records.  If @var{num} is zero then
operate on all the records.
@end table

Fields selection options:

@table @samp
@item -f
@itemx @w{@kbd{--fields}=@var{FEX}}
Field selection expression (@pxref{Field Expressions}) to select the
fields to operate.
@end table

Actions:

@table @samp
@item -s
@itemx @w{@kbd{--set}=@var{value}}
Set the value of the selected fields to @var{value}.
@item -a
@itemx @w{@kbd{--add}=@var{value}}
Add a new field to the selected record with value @var{value}.
@item -S
@itemx @w{@kbd{--set-add}=@var{value}}
Set the value of the selected fields to @var{value}.  If some of the
fields don't exist in a record, append it with the specified value.
@item -r
@itemx @w{@kbd{--rename}=@var{value}}
Rename a field.  @var{value} shall be a valid field name.  The field
expression associated with this action shall contain a single field
name and an optional subscript.  If an entire record set is selected
then the field is renamed in the record descriptor as well.
@item -d
@itemx @w{@kbd{--delete}}
Delete the selected fields in the selected records.
@item -c
@itemx @w{@kbd{--comment}}
Comment out the selected fields in the selected records.
@itemx @w{@kbd{--no-external}}
Don't use external record descriptors.
@itemx @w{@kbd{--verbose}}
Be verbose when reporting integrity problems.
@itemx @w{@kbd{--force}}
Perform the requested operation even in potentially dangerous
situations, or when the integrity of the data stored in the file is
affected.
@end table

@node recset Examples
@section recset Examples

Remove ``TmpName'' fields from any record in @file{data.rec}:

@example
$ recset -f TmpName -d data.rec
@end example

Set the secondary email of all friends to @code{invalid@@email.com}:

@example
$ recset -f Email[1] -s invalid@@email.com friends.rec
@end example

Add the email @code{new@@email.com} to John Smith:

@example
$ recset -e "Name = 'John Smith'" -f Email -a new@@email.com friends.rec
@end example

Rename the secondary email fields from @code{Email} to
@code{AltEmail}.  Modify the record descriptor as well:

@example
$ recset -f Email[1] -r AltEmail friends.rec
@end example

Add a ClosedAt field to the selected record with the current date.  In
case it already exists, set its value instead:

@example
$ recset -n 102 -f ClosedAt -S `date` tasks.rec
@end example

@node recfix
@chapter recfix

@command{recfix} checks and fixes rec files.

@menu
* recfix Invocation::     Command line options.
* recfix Examples::       Examples of the usage of @command{recfix}.
@end menu

@node recfix Invocation
@section recfix Invocation

@command{recfix} checks and fixes rec files.  Synopsis:

@example
recfix [@var{option}]@dots{} [@var{operation}] [@var{op_option}]@dots{} [@var{file}]
@end example

If no @var{file} is specified then the command acts like a filter,
getting the data from the standard input and writing the result in the
standard output.

In addition to the common options described earlier (@pxref{Common
Options}) the program accepts the following global options.

@table @samp
@itemx @w{@kbd{--no-external}}
Don't use external record descriptors.
@end table

The effect of running @command{recfix} depends on the operation it
performs.  The operation mode is selected by using one of the
following options.

@table @samp
@itemx @w{@kbd{--check}}
Check the integrity of the database contained in the file, printing
diagnostics messages in case something is not right.  This is the
default operation.
@itemx @w{@kbd{--sort}}
Perform a physical sort of all the records contained in the file (or
the standard input) after checking for its integrity.  The sorting
criteria are provided by the @code{%sort} special field, if any.  If
there is an integrity failure the sorting is not performed.

Note that this is a destructive operation.
@itemx @w{@kbd{--encrypt}}
Encrypt all the non encrypted fields in the database which are marked
as confidential.  This operation requires a password.  If no password
is specified with @option{-s} and the program is run in a terminal, a
prompt is used to get the password from the user.

If this operation is performed to a file having encrypted fields, the
operation will fail unless @w{@kbd{--force}} is used.

Note that this is a destructive operation.
@itemx @w{@kbd{--decrypt}}
Decrypt all the encrypted fields in the database which are marked as
confidential.  This operation requires a password.  If no password is
specified with @option{-s} and the program is run in a terminal, a
prompt is used to get the password from the user.

Note that this is a destructive operation.
@itemx @w{@kbd{--auto}}
Insert auto-generated fields as appropriate in the records which are
missing them.

Note that this is a destructive operation.
@end table

Some operations make use of certain specific options, which are
described in the table below.

@table @samp
@item -s @var{secret}
@itemx @w{@kbd{--password}=@var{secret}}
Password used to encrypt or decrypt fields.
@itemx @w{@kbd{--force}}
Force potentially dangerous operations.
@end table

@node recfix Examples
@section recfix Examples

Check and fix a rec database, invoked both destructively and as a
filter:

@example
$ recfix --check data.rec
$ recfix data.rec
$ cat data.rec | recfix --check data.rec
@end example

@noindent
Physically sort the record sets contained in a file:

@example
$ recfix --sort data.rec
@end example

@noindent
Encrypt any non encrypted confidential fields in a file using a given
password:

@example
$ recfix --encrypt -s "passphrase" secrets.rec
@end example

@noindent
Generate @code{Id} entries in a stockage database in records missing
them.  The record descriptor of the @code{Item} record set must be
defining @code{Id} as an auto-generated field:

@example
$ recfix --auto stockage.rec
@end example

@node recfmt
@chapter recfmt

@command{recfmt} formats records using templates.

@menu
* recfmt Invocation::    Command line options.
* recfmt Templates::     How to write templates.
* recfmt Examples::      Examples of the usage of @command{recfmt}. 
@end menu

@node recfmt Invocation
@section recfmt Invocation

@command{recfmt} formats records using templates.  Synopsis:

@example
recfmt [@var{option}]@dots{} [@var{template}]
@end example

This program always works as a filter, getting the data from the
standard input and writing the result in the standard output.

In addition to the common options described earlier (@pxref{Common
Options}) the program accepts the following options.

@table @samp
@item -f
@itemx @w{@kbd{--filename}=@var{PATH}}
Read the template from the file in @var{PATH} instead of the command
line.
@end table

@node recfmt Templates
@section recfmt Templates

A recfmt template is a text string that may contain @dfn{template
spots}.  Those spots are substituted in the template using the
information of a given record.  Any text that is not within a spot is
copied literally to the output.

Spots are written surrounded by double curly braces, like:

@example
@{@{@dots{}@}@}
@end example

Spots contain selection expressions, that are executed every time the
template is applied to a record.  The spot is then replaced by the
string representation of the value returned by the expression.

For example, consider the following template:

@example
Task @{@{Id@}@}: @{@{Summary@}@}
------------------------
@{@{Description@}@}
--
Created at @{@{CreatedAt@}@}
@end example

@noindent
When applied to the following record:

@example
Id: 123
Summary: Fix recfmt.
CreatedAt: 12 December 2010
Description:
+ The recfmt tool shall be fixed, because right
+ now it is leaking 200 megabytes per processed record.
@end example

@noindent
The result is:

@example
Task 123: Fix recfmt.
------------------------
The recfmt tool shall be fixed, because right
now it is leaking 200 megabytes per processed record.
--
Created at 12 December 2010
@end example

Note that you can use any selection expression in the slots, including
conditionals and string concatenation.

@node recfmt Examples
@section recfmt Examples

Apply a template to all the records stored in the @file{employees.rec}
file:

@example
recsel employees.rec | recfmt 'Dear @{@{Name@}@}, you are fired.'
@end example

Read the template from a file:

@example
recsel employees.rec | recfmt -f fire-letter.tmpl
@end example

@node csv2rec
@chapter csv2rec

@command{csv2rec} reads the given comma-separated-values file (or the
data in the standard input if no file is specified) and prints out the
converted rec data, if possible.

@menu
* csv2rec Invocation::     Command line options.
* csv2rec Examples::       Examples of the usage of @command{csv2rec}.
@end menu

@node csv2rec Invocation
@section csv2rec Invocation

@command{csv2rec} converts CSV data into rec data.  Synopsis:

@example
csv2rec [@var{option}]@dots{} [@var{csv_file}]
@end example

In addition of the common options described earlier (@pxref{Common
Options}) the program accepts the following options.

@table @samp
@item -t @var{type}
@itemx @w{@kbd{--type}=@var{type}}
Type of the converted records.  If no type is specified then no type
is used.
@item -s
@itemx @w{@kbd{--strict}}
Be strict parsing the csv file.
@item -e
@itemx @w{@kbd{--omit-empty}}
Omit empty fields.
@end table

@node csv2rec Examples
@section csv2rec Examples

Convert from csv to rec:

@example
$ csv2rec contacts.csv > contacts.rec
@end example

Used as a filter, and omitting empty fields:

@example
$ cat contacts.csv | csv2rec -e > contacts.rec
@end example

@node rec2csv
@chapter rec2csv

@command{rec2csv} reads the given rec files (or the data in the
standard input if no file is specified) and prints out the converted
comma-separated-values.

@menu
* rec2csv Invocation::     Command line options.
* rec2csv Conversion::     How tables are extracted from record sets.
* rec2csv Examples::       Examples of the usage of @command{rec2csv}.
@end menu

@node rec2csv Invocation
@section rec2csv Invocation

@command{rec2csv} converts rec data into CSV data.  Synopsis:

@example
rec2csv [@var{option}]@dots{} [@var{rec_file}]@dots{}
@end example

The rec data can be read from files specified in the command line, or
in the standard input.  The program echoes the converted data in the
standard output.

In addition of the common options described earlier (@pxref{Common
Options}) the program accepts the following options.

@table @samp
@item -t @var{type}
@itemx @w{@kbd{--type}=@var{type}}
Type of the records to convert.  If no type is specified then the
default records (with no name) are converted.
@item -S
@itemx @w{@kbd{--sort}=@var{fields}}
Sort the output by the comma separated list of field names
@var{fields}.  This option has precedence to whatever sorting criteria
are specified in the corresponding record descriptor with @code{%sort}.
@end table

@node rec2csv Conversion
@section rec2csv Conversion

Record sets are not tables, even if tables can be easily emulated
using records having the same fields in the same order.  For example:

@example
a: value
b: value
c: value

a: value
b: value
c: value

@dots{}
@end example

There are several ways records are more flexible than tables:

@itemize @minus
@item Fields can appear in a different order in several records.
@item There can be several fields with the same name in a single record.
@item Records can differ in the number of fields.
@end itemize

Since comma-separated-values files contain tables, the @code{rec2csv}
utility implements an algorithm that deals with the previous
difficulties, to generate a table that is what the user expects
(likewise).

The algorithm is the following.  The utility first scans the specified
record set, building a list with the names that will become the table
header.  For each field, a header is added with the form:

@example
FIELDNAME[_N]
@end example

@noindent
where N is a number in the range @code{2..inf} and is the ``index'' of
the field in its containing record plus one.  For example, consider
the following record set:

@example
a: a1
b: b11
b: b12
c: c1

a: a2
b: b2
d: d2
@end example

The corresponding list of headers being:

@example
a b b_2 c a b d
@end example

Then duplicates are removed:

@example
a b b_2 c d
@end example

The resulting list of headers is then used to build the table in the
generated csv file.  In this case:

@example
"a","b","b_2","c","d"
"a1","b11","b12","c1",
"a2","b2",,,"d2"
@end example

Note how missing fields are implemented as empty rows in the generated
csv.

@node rec2csv Examples
@section rec2csv Examples

Generate a csv file out of a rec file:

@example
$ rec2csv foo.rec > foo.csv
@end example

Same operation, but using the program as a filter and specifying a
concrete type:

@example
$ cat inventory.rec | rec2csv -t Item > items.csv
@end example

@node mdb2rec
@chapter mdb2rec

@command{mdb2rec} reads the given mdb file and prints out the
converted rec data, if possible.

@menu
* mdb2rec Invocation::      Command line options.
* mdb2rec Examples::        Examples of the usage of @command{mdb2rec}.
@end menu

@node mdb2rec Invocation
@section mdb2rec Invocation

@command{mdb2rec} converts mdb files into rec data.  Synopsis:

@example
mdb2rec [@var{option}]@dots{} @var{mdb_file} [@var{table}]
@end example

All the tables contained in the mdb file are exported unless a table
is specified in the command line.

In addition of the common options described earlier (@pxref{Common
Options}) the program accepts the following options.

@table @samp
@item -s
@itemx @w{@kbd{--system-tables}}
Include system tables in the output.
@item -l
@itemx @w{@kbd{--list-tables}}
Dump a list of the table names contained in the mdb file, one per
line.
@item -e
@itemx @w{@kbd{--keep-empty-fields}}
Don't prune empty fields in the rec output.
@end table

@node mdb2rec Examples
@section mdb2rec Examples

Access files (@dfn{mdb files}) are collections of several relations,
also known as tables.  Tables can be either @dfn{user tables} storing
user data, or @dfn{system tables} storing information such as forms,
queries or the relationships between the tables.

It is possible to get a listing with the names of all tables stored in
a mdb file by calling @command{mdb2rec} in the following way:

@example
$ mdb2rec -l sales.mdb
Customers
Products
Orders
@end example

So @file{sales.mdb} stores user information in the tables Customers,
Products and Orders.  If we want to include system tables in the
listing we can use the @kbd{-s} command line option:

@example
$ mdb2rec -s -l sales.mdb
MSysObjects
MSysACEs
MSysQueries
MSysRelationships
Customers
Products
Orders
@end example

The tables with names starting with @command{MSys} are system tables.
The data stored in those tables is either not relevant to the recutils
user (used by the Access program to create forms and the like) or is
used in an indirect way by @command{mdb2rec} (such as the information
from MSysRelationships).

Let's read some data from the @file{mdb} file.  We can get the
relation of Products in rec format:

@example
$ mdb2rec sales.mdb Products
%rec: Products
%type: ProductID int
%type: ProductName size 80
%type: Discontinued bool

ProductID: 1
ProductName: GNU generation T-shirt
Discontinued: 0

@dots{}
@end example

A @dfn{record descriptor} is created for the record set containing the
generated records, called Products.  Note that @command{mdb2rec} is
able to generate type information for the fields.  The list of
customers is similar:

@example
$ mdb2rec sales.mdb Customers
%rec: Customers
%type: CustomerID size 4
%type: CompanyName size 80
%type: ContactName size 60

CustomerID: GSOFT
CompanyName: GNU Soft
ContactName: Jose E. Marchesi

@dots{}
@end example

If no table is specified in the invocation to @command{mdb2rec} all
the tables in the file are processed, with the exception of the system
tables, for which @kbd{-s} shall be used:

@example
$ mdb2rec sales.mdb
%rec: Products
@dots{}

%rec: Customers
@dots{}

%rec: Orders
@dots{}
@end example

@node GNU Free Documentation License
@appendix GNU Free Documentation License

@include fdl.texi

@bye
