#!/bin/bash

# Simple Tasks Manager, yay!

# Copyright (C) 2010 Jose E. Marchesi

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

## Configuration ##
#
# This section contains variables that can be tweaked by the user to
# adapt the behavior of tasktool.

# Name of the project and contact email address.

tt_project_name="GNU recutils"
tt_contact_email="bug-recutils@gnu.org"

# Task types (words separated by blanks).
#
# Example: tt_task_types="Problem Task"

tt_task_types="task"

# Task statuses (words separated by blanks).
#
# Example: tt_task_statuses="Received Open InProgress"

tt_task_statuses="TODO NEXT STARTED WAITING"
tt_task_initial_status="TODO"

# Task resolutions (words separated by blanks).
#
# Example: tt_task_resolutions="Done Discarded"

tt_task_resolutions="DONE SOMEDAY DISCARDED"

# Task categories (words separated by blanks).
#
# Examples: tt_task_categories="Library Application Translations"

tt_task_categories="librec utils doc"

# Operating Systems (words separated by blanks).
#
# Examples tt_task_os="GNU Windows"

tt_task_os="GNU Windows"

# Versions (words separated by blanks).
#
# Examples tt_task_versions="0.1 0.2 0.5 0.99pre2 1.0"

# Default file containing the tasks database.  This can be overriden
# by using the '-d' command line option.
tt_db=TODO

# Tasktool depends on the GNU recutils.  If they are not installed in
# your system please get them from ftp://ftp.gnu.org/gnu/recutils
#
# The following variables contain the names of the recutils that will
# be used by the script.

tt_recsel=recsel
tt_recins=recins
tt_recdel=recdel
tt_recset=recset
tt_recfix=recfix
tt_recinf=recinf

## Internal Variables ##
#
# The user don't want to touch them.

tt_tasktool=tasktool
tt_version="0.1"
tt_copyright_holder="Jose E. Marchesi"
tt_copyright_years="2010"


tt_db_template_header="\
# -*- mode: rec -*-
#
# TODO file for ${tt_project_name}.
#
# Please contact ${tt_contact_email} for any question or
# request concerning this file."

tt_db_template_footer="\
# End of TODO"

# Tasks
#
# Tasks are known problems in the project that have to get handled
# eventually.

tt_db_task="Task"
tt_db_task_field_id="Id"
tt_db_task_field_summary="Summary"
tt_db_task_field_type="Type"
tt_db_task_field_status="Status"
tt_db_task_field_category="Category"
tt_db_task_field_description="Description"
tt_db_task_field_originator="Originator"
tt_db_task_field_assigned="AssignedTo"
tt_db_task_field_created="CreatedAt"
tt_db_task_field_closed="ClosedAt"
tt_db_task_field_note="Note"

tt_db_template_task="\
%rec: Task
%key: ${tt_db_task_field_id}
%mandatory: ${tt_db_task_field_summary} ${tt_db_task_field_status}
%type: ${tt_db_task_field_id} int
%type: ${tt_db_task_field_summary} line
%type: ${tt_db_task_field_type} enum
+ ${tt_task_types}
%type: ${tt_db_task_field_status} enum 
+ ${tt_task_statuses}
+ ${tt_task_resolutions}
%type: ${tt_db_task_field_category} enum
+ ${tt_task_categories}
%type: ${tt_db_task_field_originator} email
%type: ${tt_db_task_field_assigned} email
%type: ${tt_db_task_field_created} date
%type: ${tt_db_task_field_closed} date"

tt_db_template="\
${tt_db_template_header}

${tt_db_template_task}

${tt_db_template_footer}"

# Help messages
tt_help_footer="\
Report tasktool bugs to bug-recutils@gnu.org
tasktool home page: <http://www.gnu.org/software/recutils/tasktool/>
General help using GNU software: <http://www.gnu.org/gethelp/>"

tt_help="\
Usage: $tt_tasktool [OPTION]... SUBCOMMAND [OPTION]...
Very simple tasks manager.

Mandatory arguments to long options are mandatory for short options too.
  -d, --database=FILE                 location of the database to use.  It
                                        defaults to $tt_db.                                  
      --help                          print this help message and exit.
      --version                       print a version message and exit.

$tt_tasktool supports the following sub commands.

       init                           initialize a new database.
       list                           get a list of tasks.
       show                           print information about a given task.
       create                         create a new task.
       delete                         delete a task.
       note                           insert a note for a task.

To get detailed help on a specific sub command use '$tt_tasktool CMD
--help'.  For example:

       tasktool show --help

$tt_help_footer"

tt_help_init="\
Usage: $tt_tasktool init
Initialize a tasktool database.

Mandatory arguments to long options are mandatory for short options too.
      --help                          print this help message and exit.

Examples:

        tasktool -d my-database.rec init

$tt_help_footer"

tt_help_show="\
Usage: $tt_tasktool show [OPTION]... TASK_ID
Show information about a given task.

Mandatory arguments to long options are mandatory for short options too.
      --help                          print this help message and exit.

Examples:

        tasktool show 203

$tt_help_footer"

tt_help_list="\
Usage: $tt_tasktool list [OPTION]... [EXPRESSION]
List tasks.

Mandatory arguments to long options are mandatory for short options too.
      --help                          print this help message and exit.
  -s, --status=STATUS                 list tasks with the given status.
  -o, --originator                    list tasks with the given originator.

EXPRESSION is a recutils selection expression.  If it is specified
then any used -s or -o argument is ignored.

Examples:

        tasktool list
        tasktool list -s DISCARDED
        tasktool list -o jemarch@gnu.org
        tasktool list \"Originator ~ '\\.org'\"

$tt_help_footer"

tt_help_create="\
Usage: $tt_tasktool create [-o ORIGINATOR] [SUMMARY]
Create a new task in the database.

Mandatory arguments to long options are mandatory for short options too.
  -o, --originator=EMAIL              originator of the Task.  An email.
  -s, --status=STATUS                 status to use in task creation.  Defaults
                                        to ${tt_task_initial_status}.
  -a, --assigned=EMAIL                assignee of the task.
  -b, --batch                         don't ask for field values interactively.
      --help                          print this help message and exit.

Examples:

        tasktool create \"The function 'parse_field_name' is buggy.\"

$tt_help_footer"

tt_help_delete="\
Usage: $tt_tasktool delete [OPTION]... TASK_ID
Delete a task from the database.

Mandatory arguments to long options are mandatory for short options too.
  -c, --comment                       comment the task instead of delete.
      --help                          print this help message and exit.

Examples:

        tasktool delete 102
        tasktool -c delete 102

$tt_help_footer"

tt_help_note="\
Usage: $tt_tasktool note [OPTION...] TASK_ID [TEXT]
Add a note to the given task.

Mandatory arguments to long options are mandatory for short options too.
      --help                          print this help message and exit.

If NOTE is not specified then the program asks for it using the EDITOR
environment variable.

Examples:

        tasktool note 120 'Unit tests implemented.'
        tasktool note 100

$tt_help_footer"

# Version message
tt_version="\
$tt_tasktool $tt_version
Copyright (C) $tt_copyright_years $tt_copyright_holder
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>.
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law."

## Recutils Interface ##

# Check the availability of the GNU recutils.  If they are not found,
# notify the user and exit.
tt_rec_check_utility ()
{
    # Parameters:
    # $1 => The name of the utility to check.
    test "$#" -gt "0" && {
        ${1} --version 2>&1 > /dev/null < /dev/null || tt_error "'$1' not found"
    }
}

tt_rec_check_utilities ()
{
    for u in $tt_recinf \
             $tt_recfix \
             $tt_recsel \
             $tt_recins \
             $tt_recdel \
             $tt_recset
    do
        tt_rec_check_utility $u
    done
}

## DB Interface ##
#
# Accessing the tasks database.

# Test whether the database can be read and is correct.
tt_db_check ()
{
    test -f ${tt_db} || \
        {
           tt_error "cannot open database in '$tt_db'.  Use 'init' to create one."
        }

    $tt_recfix ${tt_db}
    if test "$?" != "0"
    then
        tt_error "data integrity problem in '${tt_db}'.  See the errors above."
        exit 1
    fi
}

# Create a new, empty database.
tt_db_create ()
{
    test -f ${tt_db} && {
        tt_error "database already exists in '$tt_db'."
        return
    }

    echo "$tt_db_template" > ${tt_db}
    echo "$tt_tasktool: database initialized in ${tt_db}."
}

# Test whether a task with the given ID exists in the database.
#
# Parameters:
# $1 => Id of a task.
tt_db_task_p ()
{
    COUNT=`${tt_recsel} -t ${tt_db_task} -e "${tt_db_task_field_id} = $1" -c ${tt_db}`
    if test "$COUNT" -gt "0"
    then
        return 0
    fi

    return 1
}

# Test whether a given string correspond to a status.
#
# Parameters:
# $1 => The status to check.
tt_db_status_p ()
{
    # We need to check in both tt_task_statuses and
    # tt_task_resolutions.
    if tt_word_in_list $1 $tt_task_statuses || \
       tt_word_in_list $1 $tt_task_resolutions
    then
        return 0
    fi

    return 1
}

# Show a given task
# Parameters:
# $1 => Id of the task to show.
tt_db_show_task ()
{
    ${tt_recsel} -t ${tt_db_task} -e "${tt_db_task_field_id} = $1" ${tt_db}
}

# Get a free ID for a task.
tt_db_free_id ()
{
    max_id=0
    for id in `${tt_recsel} -t ${tt_db_task} -P ${tt_db_task_field_id} ${tt_db}`
    do
        if test $id -gt $max_id
        then
            max_id=$id
        fi
    done

    max_id=`expr $max_id + 1`

    echo "$max_id"
}

## VC Interface ##
#
# Functions to interact with version control systems and hide its
# details.  Each operation OP implemented in this interface involves
# the creation of a couple of functions:
#
# tt_vc_OP
#
#    The VC-independent function.
#
# tt_vc_XXX_OP
#
#    Where XXX is the name of a supported version control system.

# Supported VCs
tt_supported_vcs="cvs git bzr"

## Utility Functions ##
#
# Misc functions used by the script.

# Print a message and exit with an error status.
tt_error ()
{
    if test "$#" -gt "0"
    then
        echo "error: $1" 2>&1
    fi
    
    exit 1
}

# Print a message and continue.
tt_warning ()
{
    if test "$#" -gt "0"
    then
        echo "warning: $1" 2>&1
    fi
}

# Determine whether a word is part of a list of words separated by
# blanks.
tt_word_in_list ()
{
    word=$1
    list=$2
    for elem in $list
    do
        if test "x$elem" = "x$word"
        then
            # Found it.
            return 0
        fi
    done

    # Not found.
    return 1
}

# Test whether a given string is a valid email.
#
# Parameters:
# $1 => The string to check.
tt_email_p ()
{
    if echo -n $1 \
       | grep -E '^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,4}$' > /dev/null
    then
        return 0
    fi

    return 1
}

## Implementation of subcommands ##
#
# Each subcommand is implemented by a tt_process_cmd_COMMAND function.
   
# Process the 'init' subcommand
tt_process_cmd_init ()
{
    TEMP=`getopt -o f:: --long help -n 'tasktool: init' -- "$@"`
    if test "$?" != "0"
    then
        exit 1
    fi
    eval set -- "$TEMP" || exit 1;

    while true
    do
        case "$1" in
            --help)
                echo "$tt_help_init"
                exit 1
                ;;
            *)
                shift
                break
                ;;
        esac
    done

    # Initialize the database
    tt_db_create
}

# Process the 'note' subcommand
tt_process_cmd_note ()
{
    TEMP=`getopt -o f: --long help -n 'tasktool: note' -- "$@"`
    if test "$?" != "0"
    then
        exit 1
    fi
    eval set -- "$TEMP" || exit 1;

    while true
    do
        case "$1" in
            --help)
                echo "$tt_help_note"
                exit 1
                ;;
            *)
                shift
                break
                ;;
        esac
    done

    # Get the ID of the task to annotate.
    if test "$#" -lt "1"
    then
        echo "$tt_help_note"
        exit 1
    fi

    # Check if a task with a given ID exists.
    tt_db_task_p "$1" || \
        { echo "$tt_tasktool: task '$1' not found."; exit 1; }
    task_id="$1"
    shift;

    # Maybe get the note from the command line.
    if test "$#" = "1"
    then
        date=`date`
        note="$date

$1"
    else
        # Get the contents of the note from EDITOR
        if test "$note" = ""; then
            tmpfile=$$.tmp
            if test -w $tmpfile; then
                rm -f $tmpfile
            fi
            date=`date`
            echo "$date

Please replace this line with the annotation for the task." > $tmpfile
            $EDITOR $tmpfile
            note=`cat $tmpfile`
            rm -f $tmpfile
            
            if test "$note" = ""; then
                while test "$yesno" != "yes" && test "$yesno" != "no"
                do
                    echo -n "Got an empty annotation! Continue? (yes/no): "
                    read yesno
                done
                
                if test "$yesno" = "no"; then
                    echo "Creation of task aborted."
                    exit 0
                fi
            fi
        fi
    fi
        
    # Add the annotation to the database.
    $tt_recset --verbose \
        -t ${tt_db_task} -e "${tt_db_task_field_id} = $task_id" \
        -f ${tt_db_task_field_note} -a "$note" \
        $tt_db
    if test "$?" != "0"
    then
        tt_error "error adding the annotation.  See the errors above."
        exit 1
    else
        echo "tasktool: task $task_id annotated."
    fi
}

# Process the 'show' subcommand
tt_process_cmd_show ()
{
    TEMP=`getopt -o f: --long help -n 'tasktool: show' -- "$@"`
    if test "$?" != "0"
    then
        exit 1
    fi
    eval set -- "$TEMP" || exit 1;

    while true
    do
        case "$1" in
            --help)
                echo "$tt_help_show"
                exit 1
                ;;
            *)
                shift
                break
                ;;
        esac
    done

    # Get the ID of the task to show.
    if test "$#" != "1"
    then
        echo "$tt_help_show"
        exit 1
    fi

    # Check for the existance of the task.
    tt_db_task_p "$1" || \
        { echo "$tt_tasktool: task '$1' not found."; exit 1; }
    tt_db_show_task "$1"
}

# Process the 'list' subcommand
tt_process_cmd_list ()
{
    TEMP=`getopt -o -e:s:o: --long help,status,originator -n 'tasktool: list' -- "$@"`
    if test "$?" != "0"
    then
        exit 1
    fi
    eval set -- "$TEMP" || exit 1;

    selection_expression=""
    status=""
    originator=""
    while true
    do
        case "$1" in
            --help)
                echo "$tt_help_list"
                exit 1
                ;;
            -s|--status)
                status="$2"
                shift
                shift
                ;;
            -o|--originator)
                originator="$2"
                shift
                shift
                ;;
            *)
                break
                ;;
        esac
    done

    # Check parameters.

    if test -n "$originator"
    then
        tt_email_p $originator || \
          { tt_error "'$originator' is not a proper email address."; exit 1; }
    fi

    if test "$#" != "1"
    then
        if test "$#" == "2"
        then
            selection_expression="$1"
        else 
            echo "$tt_help_list"
            exit 1
        fi
    fi

    # Prepare the selection expression
    if test -n "$selection_expression"
    then
        if test -n "$status"
        then
            tt_warning "ignoring -s $status"
        fi

        if test -n "$originator"
        then
            tt_warning "ignoring -o $originator"
        fi
    else
        selection_expression="1"

        if test -n "$status"
        then
            selection_expression="$selection_expression && (Status = '$status')"
        fi
        
        if test -n "$originator"
        then
            selection_expression="$selection_expression && (Originator = '$originator')"
        fi
    fi

    ${tt_recsel} -t ${tt_db_task} -e "$selection_expression" -C \
                 -R ${tt_db_task_field_id},${tt_db_task_field_summary} ${tt_db}
}

# Process the 'create' subcommand
tt_process_cmd_create ()
{
    TEMP=`getopt -o -bs:o:a: --long help,batch,originator,status:,assigned:,summary: -n 'tasktool: create' -- "$@"`
    if test "$?" != "0"
    then
        exit 1
    fi
    eval set -- "$TEMP" || exit 1;

    while true
    do
        case "$1" in
            --help)
                echo "$tt_help_create"
                exit 1
                ;;
            -o|--originator)
                originator=$2
                shift
                shift
                ;;
            -s|--status)
                status=$2
                shift
                shift
                ;;
            -a|--assigned)
                assigned=$2
                shift
                shift
                ;;
            -b|--batch)
                batch_mode=yes
                shift
                ;;
            *)
                break
                ;;
        esac
    done

    # Check the parameters.

    if test -n "$status"
    then
        tt_db_status_p $status || \
          { tt_error "'$status' is not a proper status."; exit 1; }
    else
        status=$tt_task_initial_status
    fi


    if test -n "$originator"
    then
        tt_email_p $originator || \
          { tt_error "'$originator' is not a proper email address."; exit 1; }
    fi

    if test -n "$assigned"
    then
        tt_email_p $assigned || \
          { tt_error "'$assigned' is not a proper email address."; exit 1; }
    fi

    # Assigned defaults to originator.
    if test -n "$originator" && test -z "$assigned"
    then
        assigned="$originator"
    fi

    if test "$#" != "1"
    then
        if test "$#" == "2"
        then
            # Set the summary.
            summary="$1"
        else 
            echo "$tt_help_create"
            exit 1
        fi
    fi

    if test "$summary" = ""; then
        while test "$summary" = ""
        do
            echo -n "Summary (one line): "
            read summary
        done
    fi

    if test "$description" = "" && test -z "$batch_mode"; then

        tmpfile=$$.tmp
        if test -w $tmpfile; then
            rm -f $tmpfile
        fi
        echo "Please replace this line with a description of the task." > $tmpfile
        $EDITOR $tmpfile
        description=`cat $tmpfile`
        rm -f $tmpfile

        if test "$description" = ""; then
            while test "$yesno" != "yes" && test "$yesno" != "no"
            do
                echo -n "Got an empty description! Continue? (yes/no): "
                read yesno
            done

            if test "$yesno" = "no"; then
                echo "Operation aborted."
                exit 0
            fi
        fi
    fi

    new_id=`tt_db_free_id`
    date=`date`

    # A closing date may be in order.
    if tt_word_in_list $status $tt_task_resolutions
    then
        closed_at_cmd="-f ${tt_db_task_field_closed} -v '`date`'"
    else
        closed_at_cmd=""
    fi

    # Add the new task to the database.
    if test -n "$originator"
    then
        originator_cmd="-f ${tt_db_task_field_originator} -v '$originator'"
    else
        originator_cmd=""
    fi

    if test -n "$assigned"
    then
        assigned_cmd="-f ${tt_db_task_field_assigned} -v '$assigned'"
    else
        assigned_cmd=""
    fi

    if test -n "$description"
    then
        description_cmd="-f ${tt_db_task_field_description} -v '$description'"
    else
        description_cmd=""
    fi

    # Escape single quotes.
    summary=`echo "$summary" | sed "s/'/'\\\\\\\\''/g"`
    description=`echo "$description" | sed "s/'/'\\\\\\\\''/g"`

    cmd="$tt_recins --verbose \
                    -t ${tt_db_task} \
                    -f ${tt_db_task_field_id} -v $new_id \
                    -f ${tt_db_task_field_summary} -v '$summary' \
                    -f ${tt_db_task_field_created} -v '$date' \
                    ${originator_cmd} \
                    ${assigned_cmd} \
                    ${closed_at_cmd} \
                    -f ${tt_db_task_field_status} -v $status \
                    ${description_cmd} \
                    $tt_db"
    eval "$cmd"
    if test "$?" != "0"
    then
        tt_error "data integrity problem.  See the errors above and review your parameters."
        exit 1
    else
        echo "tasktool: task $new_id added to $tt_db."
    fi
}

# Process the 'delete' subcommand
tt_process_cmd_delete ()
{
    TEMP=`getopt -o c --long help,comment -n 'tasktool: delete' -- "$@"`
    if test "$?" != "0"
    then
        exit 1
    fi
    eval set -- "$TEMP" || exit 1;
    
    task_id=""
    do_comment=""

    while true
    do
        case "$1" in
            --help)
                echo "$tt_help_delete"
                exit 1
                ;;
            -c|--comment)
                do_comment="-c"
                shift
                ;;
            *)
                shift
                break
                ;;
        esac
    done

    # Get the ID of the task to delete.
    if test "$#" = "1"
    then
        task_id="$1"
    else
        echo "$tt_help_delete"
        exit 1
    fi

    # Check for the existance of the task.
    tt_db_task_p "$1" || \
        { echo "$tt_tasktool: task '$1' not found."; exit 1; }
    
    # Remove (or comment out) the task from the databse.
    cmd="$tt_recdel ${do_comment} \
         -t ${tt_db_task} -e \"${tt_db_task_field_id} = $task_id\" $tt_db"
    eval "$cmd"
    if test "$?" != "0"
    then
        tt_error "data integrity problem.  See the errors above and review your parameters."
        exit 1
    else
        if test -n "$do_comment"
        then
            echo "tasktool: task $task_id commented out in $tt_db."
        else
            echo "tasktool: task $task_id removed from $tt_db."
        fi
    fi
}

# Parse arguments and set some variables.
tt_parse_arguments ()
{
    TEMP=`getopt -o +d: --long help,database:,version -n 'tasktool' -- "$@"`
    if test "$?" != "0"
    then
        exit 1
    fi
    eval set -- "$TEMP" || exit 1;
    
    while true
    do
        case "$1" in
            --version)
                echo "$tt_version"
                shift
                break
                ;;
            init)
                shift
                tt_process_cmd_init "$@"
                break
                ;;
            show)
                shift
                tt_db_check
                tt_process_cmd_show "$@"
                break
                ;;
            note)
                shift
                tt_db_check
                tt_process_cmd_note "$@"
                break
                ;;
            list)
                shift
                tt_db_check
                tt_process_cmd_list "$@"
                break
                ;;
            create)
                shift
                tt_db_check
                tt_process_cmd_create "$@"
                break
                ;;
            delete)
                shift
                tt_db_check
                tt_process_cmd_delete "$@"
                break
                ;;
            -d|--database)
                tt_db="$2"
                shift; shift;
                ;;
            --)
                shift
                ;;
            --help)
                echo "$tt_help"
                exit 1
                ;;
            *)
                echo "$tt_help"
                break
                ;;
        esac
    done
}

## Start! ##

tt_parse_arguments "$@"

# End of tasktool
