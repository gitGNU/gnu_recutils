#!/bin/bash

# Simple Tasks Manager, yay!

# Copyright (C) 2010 Jose E. Marchesi

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

## Configuration ##
#
# This section contains variables that can be tweaked by the user to
# adapt the behavior of tasktool.

# File containing the tasks database.
tt_db=TODO

# Tasktool depends on the GNU record utilities to work.  If they are
# not installed in your system please get them from
# ftp://ftp.gnu.org/gnu/recutils
#
# The following variables contain the names of the recutils that will
# be used by the script.

tt_recsel=recsel
tt_recins=recins
tt_recdel=recdel
tt_recset=recset
tt_recfix=recfix
tt_recinf=recinf

## Internal Variables ##
#
# The user don't want to touch them.

tt_tasktool=tasktool
tt_version="0.1"
tt_copyright_holder="Jose E. Marchesi"
tt_copyright_years="2010"

tt_db_issue="Issue"
tt_db_field_id="Id"
tt_db_field_summary="Summary"
tt_db_field_type="Type"
tt_db_field_status="Status"
tt_db_field_description="Description"
tt_db_field_originator="Originator"
tt_db_field_assignee="Assignee"
tt_db_field_assigned="Assigned"
tt_db_field_component="Component"
tt_db_field_created="Created"
tt_db_field_note="Note"

tt_db_template="\
# -*- mode: rec -*-
#
# TODO file for the GNU recutils.

%rec: Issue
%key: ${tt_db_field_id}
%mandatory: ${tt_db_field_summary}
%type: ${tt_db_field_summary} line
%type: ${tt_db_field_type} enum improvement bug
%type: ${tt_db_field_status} enum TODO NEXT STARTED WAITING DISCARDED
%type: ${tt_db_field_originator} email
%type: ${tt_db_field_assignee} email
%type: ${tt_db_field_assigned} email
%type: ${tt_db_field_component} enum librec utils rec-mode
%type: ${tt_db_field_created} date
"

# Help messages
tt_help_footer="\
Report tasktool bugs to bug-recutils@gnu.org
tasktool home page: <http://www.gnu.org/software/recutils/tasktool/>
General help using GNU software: <http://www.gnu.org/gethelp/>"

tt_help="\
Usage: $tt_tasktool [OPTION]... SUBCOMMAND [OPTION]...
Very simple tasks manager.

Mandatory arguments to long options are mandatory for short options too.
  -d, --database=FILE                 location of the database to use.  It
                                        defaults to $tt_db.                                  
      --help                          print this help message and exit.
      --version                       print a version message and exit.

$tt_tasktool supports the following sub commands.

       init                           initialize a new database in the default
                                        location.
       list                           get a list of issues.
       show                           print information about a given issue.
       create                         create a new issue.
       note                           insert a note for an issue.

To get detailed help on a specific sub command use '$tt_tasktool CMD
--help'.  For example:

       tasktool show --help

$tt_help_footer"

tt_help_init="\
Usage: $tt_tasktool init
Initialize a tasktool database.

Mandatory arguments to long options are mandatory for short options too.
      --help                          print this help message and exit.

Examples:

        tasktool -d my-database.rec init

$tt_help_footer"

tt_help_show="\
Usage: $tt_tasktool show [OPTION]... ISSUE_ID
Show information about a given issue.

Mandatory arguments to long options are mandatory for short options too.
      --help                          print this help message and exit.

Examples:

        tasktool show 203

$tt_help_footer"

tt_help_list="\
Usage: $tt_tasktool list [OPTION]...
List issues.

Mandatory arguments to long options are mandatory for short options too.
      --help                          print this help message and exit.
  -s, --status=STATUS                 list issues with the given status.
  -o, --originator                    list issues with the given originator.

Examples:

        tasktool list
        tasktool list -s DISCARDED
        tasktool list -o jemarch@gnu.org

$tt_help_footer"

tt_help_create="\
Usage: $tt_tasktool create -t SUMMARY
Create a new issue in the database.

Mandatory arguments to long options are mandatory for short options too.
  -s, --summary=STR                   summary for the new issue.  This option is
                                        mandatory.
  -o, --originator=EMAIL              originator of the Issue.  An email.
  -i, --id=NUMBER                     the ID of the new issue.  If this option is not
                                        used then an ID is created for the new issue.
      --help                          print this help message and exit.

Examples:

        tasktool create \"The function 'parse_field_name' is buggy.\"

$tt_help_footer"

tt_help_note="\
Usage: $tt_tasktool note [OPTION...] ISSUE_ID
Add a note to the given issue.

Mandatory arguments to long options are mandatory for short options too.
      --help                          print this help message and exit.

Examples:

        tasktool note 120

$tt_help_footer"

# Version message
tt_version="\
$tt_tasktool $tt_version
Copyright (C) $tt_copyright_years $tt_copyright_holder
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>.
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law."

## Recutils Interface ##

# Check the availability of the GNU recutils.  If they are not found,
# notify the user and exit.
tt_rec_check_utility ()
{
    # Parameters:
    # $1 => The name of the utility to check.
    test "$#" -gt "0" && {
        ${1} --version 2>&1 > /dev/null < /dev/null || tt_error "$1 not found"
    }
}

tt_rec_check_utilities ()
{
    for u in $tt_recinf \
             $tt_recfix \
             $tt_recsel \
             $tt_recins \
             $tt_recdel \
             $tt_recset
    do
        tt_rec_check_utility $u
    done
}

## DB Interface ##
#
# Accessing the tasks database.

# Test whether the database can be read and is correct.
tt_db_check ()
{
    test -f ${tt_db} || \
        {
           tt_error "cannot open database in $tt_db.  Use 'init' to create one."
        }

    $tt_recfix ${tt_db}
    if test "$?" != "0"
    then
        tt_error "data integrity problem in ${tt_cb}.  See the errors above."
        exit 1
    fi
}

# Create a new, empty database.
tt_db_create ()
{
    test -f ${tt_db} && {
        tt_error "database already exists in $tt_db."
        return
    }

    echo "$tt_db_template" > ${tt_db}
    echo "$tt_tasktool: database initialized in ${tt_db}."
}

# Test whether a task with the given ID exists in the database.
#
# Parameters:
# $1 => Id of a task.
tt_db_task_p ()
{
    COUNT=`${tt_recsel} -t ${tt_db_issue} -e "${tt_db_field_id} = $1" -c ${tt_db}`
    if test "$COUNT" -gt "0"
    then
        return 0
    fi

    return 1
}

# Show a given issue
# Parameters:
# $1 => Id of the task to show.
tt_db_show_task ()
{
    ${tt_recsel} -t ${tt_db_issue} -e "${tt_db_field_id} = $1" ${tt_db}
}

# Get a free ID for an issue.
tt_db_free_id ()
{
    max_id=0
    for id in `${tt_recsel} -t ${tt_db_issue} -P ${tt_db_field_id} ${tt_db}`
    do
        if test $id -gt $max_id
        then
            max_id=$id
        fi
    done

    max_id=`expr $max_id + 1`

    if test "$max_id -lt 10"; then
        id_prefix="0000"
    elif test "$max_id -lt 100"; then
        id_prefix="000"
    elif test "$max_id -lt 1000"; then
        id_prefix="00"
    elif test "$max_id -lt 10000"; then
        id_prefix="0"
    else
        id_prefix=""
    fi

    echo "$id_prefix$max_id"
}

## VC Interface ##
#
# Functions to interact with version control systems and hide its
# details.  Each operation OP implemented in this interface involves
# the creation of a couple of functions:
#
# tt_vc_OP
#
#    The VC-independent function.
#
# tt_vc_XXX_OP
#
#    Where XXX is the name of a supported version control system.

# Supported VCs
tt_supported_vcs="cvs git bzr"

## Utility Functions ##
#
# Misc functions used by the script.

# Print a message and exit with an error status.
tt_error ()
{
    if test "$#" -gt "0"
    then
        echo "error: $1" 2>&1
    fi
    
    exit 1
}

# Process the 'init' subcommand
tt_process_cmd_init ()
{
    TEMP=`getopt -o f:: --long help -n 'tasktool: init' -- "$@"`
    if test "$?" != "0"
    then
        exit 1
    fi
    eval set -- "$TEMP" || exit 1;

    while true
    do
        case "$1" in
            --help)
                echo "$tt_help_init"
                exit 1
                ;;
            *)
                shift
                break
                ;;
        esac
    done

    # Initialize the database
    tt_db_create
}

# Process the 'note' subcommand
tt_process_cmd_note ()
{
    TEMP=`getopt -o f: --long help -n 'tasktool: note' -- "$@"`
    if test "$?" != "0"
    then
        exit 1
    fi
    eval set -- "$TEMP" || exit 1;

    while true
    do
        case "$1" in
            --help)
                echo "$tt_help_note"
                exit 1
                ;;
            *)
                shift
                break
                ;;
        esac
    done

    # Get the ID of the task to annotate.
    if test "$#" != "1"
    then
        echo "$tt_help_note"
        exit 1
    fi

    # Check if a task with a given ID exists.
    tt_db_task_p "$1" || \
        { echo "$tt_tasktool: issue '$1' not found."; exit 1; }


    # Get the contents of the note from EDITOR
    if test "$note" = ""; then
        tmpfile=$$.tmp
        if test -w $tmpfile; then
            rm -f $tmpfile
        fi
        date=`date`
        echo "$date

Please replace this line with the annotation for the issue." > $tmpfile
        $EDITOR $tmpfile
        note=`cat $tmpfile`
        rm -f $tmpfile

        if test "$note" = ""; then
            while test "$yesno" != "yes" -a "$yesno" != "no"
            do
                echo -n "Got an empty annotation! Continue? (yes/no): "
                read yesno
            done

            if test "$yesno" = "no"; then
                echo "Creation of issue aborted."
                exit 0
            fi
        fi
    fi

    # Add the annotation to the database.
    $tt_recset --verbose \
        -t ${tt_db_issue} -e "${tt_db_field_id} = $1" \
        -f ${tt_db_field_note} -a "$note" \
        $tt_db
    if test "$?" != "0"
    then
        tt_error "error adding the annotation.  See the errors above."
        exit 1
    else
        echo "tasktool: issue $1 annotated."
    fi
}

# Process the 'show' subcommand
tt_process_cmd_show ()
{
    TEMP=`getopt -o f: --long help -n 'tasktool: show' -- "$@"`
    if test "$?" != "0"
    then
        exit 1
    fi
    eval set -- "$TEMP" || exit 1;

    while true
    do
        case "$1" in
            --help)
                echo "$tt_help_show"
                exit 1
                ;;
            *)
                shift
                break
                ;;
        esac
    done

    # Get the ID of the task to show.
    if test "$#" != "1"
    then
        echo "$tt_help_show"
        exit 1
    fi

    # Check if a task with a given ID exists.
    tt_db_task_p "$1" || \
        { echo "$tt_tasktool: issue '$1' not found."; exit 1; }
    tt_db_show_task "$1"
}

# Process the 'list' subcommand
tt_process_cmd_list ()
{
    TEMP=`getopt -o -e:s:o: --long help,status,originator -n 'tasktool: list' -- "$@"`
    if test "$?" != "0"
    then
        exit 1
    fi
    eval set -- "$TEMP" || exit 1;

    selection_expression="1"
    status=""
    originator=""
    while true
    do
        case "$1" in
            --help)
                echo "$tt_help_list"
                exit 1
                ;;
            -s|--status)
                status="$2"
                shift
                shift
                ;;
            -o|--originator)
                originator="$2"
                shift
                shift
                ;;
            *)
                shift
                break
                ;;
        esac
    done

    if test "$#" != "0"
    then
        echo "$tt_help_list"
        exit 1
    fi

    # Prepare the selection expression
    if test -n "$status"
    then
        selection_expression="$selection_expression && (Status = '$status')"
    fi

    if test -n "$originator"
    then
        selection_expression="$selection_expression && (Originator = '$originator')"
    fi

    ${tt_recsel} -t ${tt_db_issue} -e "$selection_expression" -C \
                 -R ${tt_db_field_id},${tt_db_field_summary} ${tt_db}
}

# Process the 'create' subcommand
tt_process_cmd_create ()
{
    TEMP=`getopt -o -s:o: --long help,originator,summary: -n 'tasktool: create' -- "$@"`
    if test "$?" != "0"
    then
        exit 1
    fi
    eval set -- "$TEMP" || exit 1;

    while true
    do
        case "$1" in
            --help)
                echo "$tt_help_create"
                exit 1
                ;;
            -s|--summary)
                summary=$2
                shift
                shift
                ;;
            -o|--originator)
                originator=$2
                shift
                shift
                ;;
            *)
                shift
                break
                ;;
        esac
    done

    if test "$#" != "0"
    then
        echo "$tt_help_create"
        exit 1
    fi

    if test "$summary" = ""; then
        while test "$summary" = ""
        do
            echo -n "Summary (line): "
            read summary
        done
    fi

    if test "$originator" = ""; then
        while test "$originator" = ""
        do
            echo -n "Originator (email): "
            read originator
        done
    fi

    if test "$description" = ""; then

        tmpfile=$$.tmp
        if test -w $tmpfile; then
            rm -f $tmpfile
        fi
        echo "Please replace this line with a description of the issue." > $tmpfile
        $EDITOR $tmpfile
        description=`cat $tmpfile`
        rm -f $tmpfile

        if test "$description" = ""; then
            while test "$yesno" != "yes" -a "$yesno" != "no"
            do
                echo -n "Got an empty description! Continue? (yes/no): "
                read yesno
            done

            if test "$yesno" = "no"; then
                echo "Annotation aborted."
                exit 0
            fi
        fi
    fi

    new_id=`tt_db_free_id`
    date=`date`

    # Add the new issue to the database.
    eval $tt_recins --verbose \
                    -t ${tt_db_issue} \
                    -f ${tt_db_field_id} -v $new_id \
                    -f ${tt_db_field_summary} -v \'$summary\' \
                    -f ${tt_db_field_created} -v \'$date\' \
                    -f ${tt_db_field_originator} -v \'$originator\' \
                    -f ${tt_db_field_status} -v TODO \
                    -f ${tt_db_field_description} -v \'"$description"\' \
                    $tt_db
    if test "$?" != "0"
    then
        tt_error "data integrity problem.  See the errors above and review your parameters."
        exit 1
    else
        echo "tasktool: issue $new_id added to $tt_db."
    fi
}

# Parse arguments and set some variables.
tt_parse_arguments ()
{
    TEMP=`getopt -o +d: --long help,database:,version -n 'tasktool' -- "$@"`
    if test "$?" != "0"
    then
        exit 1
    fi
    eval set -- "$TEMP" || exit 1;
    
    while true
    do
        case "$1" in
            --version)
                echo "$tt_version"
                shift
                break
                ;;
            init)
                shift
                tt_process_cmd_init $*
                break
                ;;
            show)
                shift
                tt_db_check
                tt_process_cmd_show $*
                break
                ;;
            note)
                shift
                tt_db_check
                tt_process_cmd_note $*
                break
                ;;
            list)
                shift
                tt_db_check
                tt_process_cmd_list $*
                break
                ;;
            create)
                shift
                tt_db_check
                tt_process_cmd_create $*
                break
                ;;
            -d|--database)
                tt_db="$2"
                shift; shift;
                ;;
            --)
                shift
                ;;
            --help)
                echo "$tt_help"
                exit 1
                ;;
            *)
                # Do nothing
                break;
                ;;
        esac
    done
}

## Start! ##

tt_rec_check_utilities
tt_parse_arguments $*

# End of tasktool
